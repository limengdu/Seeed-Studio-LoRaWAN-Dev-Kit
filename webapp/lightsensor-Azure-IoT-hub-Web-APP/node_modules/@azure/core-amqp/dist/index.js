'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var abortController = require('@azure/abort-controller');
var rheaPromise = require('rhea-promise');
var AsyncLock = _interopDefault(require('async-lock'));
var logger$1 = require('@azure/logger');
var dns = require('dns');
var isBuffer = _interopDefault(require('is-buffer'));
var buffer = require('buffer');
var coreAuth = require('@azure/core-auth');
var jssha = _interopDefault(require('jssha'));
var os = require('os');

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const associatedLinkName = "associated-link-name";
const partitionKey = "x-opt-partition-key";
const sequenceNumber = "x-opt-sequence-number";
const enqueueSequenceNumber = "x-opt-enqueue-sequence-number";
const enqueuedTime = "x-opt-enqueued-time";
const scheduledEnqueueTime = "x-opt-scheduled-enqueue-time";
const offset = "x-opt-offset";
const lockedUntil = "x-opt-locked-until";
const partitionIdName = "x-opt-partition-id";
const publisher = "x-opt-publisher-name";
const viaPartitionKey = "x-opt-via-partition-key";
const deadLetterSource = "x-opt-deadletter-source";
const enqueuedTimeAnnotation = `amqp.annotation.${enqueuedTime}`;
const offsetAnnotation = `amqp.annotation.${offset}`;
const sequenceNumberAnnotation = `amqp.annotation.${sequenceNumber}`;
const guidSize = 16;
const message = "message";
const error = "error";
const statusCode = "status-code";
const statusDescription = "status-description";
const errorCondition = "error-condition";
const management = "$management";
const partition = "partition";
const partitionId = "partitionId";
const readOperation = "READ";
const TLS = "tls";
const establishConnection = "establishConnection";
const defaultConsumerGroup = "$default";
const eventHub = "eventhub";
const cbsEndpoint = "$cbs";
const cbsReplyTo = "cbs";
const operationPutToken = "put-token";
const aadEventHubsAudience = "https://eventhubs.azure.net/";
const aadEventHubsScope = "https://eventhubs.azure.net//.default";
const aadServiceBusAudience = "https://servicebus.azure.net/";
const aadServiceBusScope = "https://servicebus.azure.net//.default";
const maxUserAgentLength = 512;
const vendorString = "com.microsoft";
const attachEpoch = `${vendorString}:epoch`;
const receiverIdentifierName = `${vendorString}:receiver-name`;
const enableReceiverRuntimeMetricName = `${vendorString}:enable-receiver-runtime-metric`;
const timespan = `${vendorString}:timespan`;
const uri = `${vendorString}:uri`;
const dateTimeOffset = `${vendorString}:datetime-offset`;
const sessionFilterName = `${vendorString}:session-filter`;
const receiverError = "receiver_error";
const senderError = "sender_error";
const sessionError = "session_error";
const connectionError = "connection_error";
const defaultOperationTimeoutInMs = 60000;
const defaultConnectionIdleTimeoutInMs = 60000;
const managementRequestKey = "managementRequest";
const negotiateCbsKey = "negotiateCbs";
const negotiateClaim = "negotiateClaim";
const ensureContainerAndBlob = "ensureContainerAndBlob";
const defaultPrefetchCount = 1000;
const reconnectLimit = 100;
const maxMessageIdLength = 128;
const maxPartitionKeyLength = 128;
const maxSessionIdLength = 128;
const pathDelimiter = "/";
const ruleNameMaximumLength = 50;
const maximumSqlFilterStatementLength = 1024;
const maximumSqlRuleActionStatementLength = 1024;
const maxDeadLetterReasonLength = 4096;
// https://stackoverflow.com/questions/11526504/minimum-and-maximum-date for js
// However we are setting this to the TimeSpan.MaxValue of C#.
const maxDurationValue = 922337203685477;
const minDurationValue = -922337203685477;
// https://github.com/Azure/azure-amqp/blob/master/Microsoft.Azure.Amqp/Amqp/AmqpConstants.cs#L47
const maxAbsoluteExpiryTime = new Date("9999-12-31T07:59:59.000Z").getTime();
const aadTokenValidityMarginInMs = 5000;
const connectionReconnectDelay = 300;
const defaultMaxRetries = 3;
const defaultMaxRetriesForConnection = 150;
const defaultDelayBetweenOperationRetriesInMs = 30000;
const defaultMaxDelayForExponentialRetryInMs = 90000;
const receiverSettleMode = "receiver-settle-mode";
const dispositionStatus = "disposition-status";
const fromSequenceNumber = "from-sequence-number";
const messageCount = "message-count";
const lockTokens = "lock-tokens";
const messageIdMapKey = "message-id";
const sequenceNumberMapKey = "sequence-number";
const lockTokenMapKey = "lock-token";
const sessionIdMapKey = "session-id";
const sequenceNumbers = "sequence-numbers";
const deadLetterReason = "deadletter-reason";
const deadLetterDescription = "deadletter-description";
const propertiesToModify = "properties-to-modify";
const deadLetterName = "com.microsoft:dead-letter";
const trackingId = "com.microsoft:tracking-id";
const serverTimeout = "com.microsoft:server-timeout";
const operations = {
    putToken: "put-token",
    read: "READ",
    cancelScheduledMessage: "com.microsoft:cancel-scheduled-message",
    scheduleMessage: "com.microsoft:schedule-message",
    renewLock: "com.microsoft:renew-lock",
    peekMessage: "com.microsoft:peek-message",
    receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number",
    updateDisposition: "com.microsoft:update-disposition",
    renewSessionLock: "com.microsoft:renew-session-lock",
    setSessionState: "com.microsoft:set-session-state",
    getSessionState: "com.microsoft:get-session-state",
    enumerateSessions: "com.microsoft:get-message-sessions",
    addRule: "com.microsoft:add-rule",
    removeRule: "com.microsoft:remove-rule",
    enumerateRules: "com.microsoft:enumerate-rules"
};
const descriptorCodes = {
    ruleDescriptionList: 1335734829060,
    sqlFilterList: 83483426822,
    correlationFilterList: 83483426825,
    sqlRuleActionList: 1335734829062,
    trueFilterList: 83483426823,
    falseFilterList: 83483426824
};

var constants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    associatedLinkName: associatedLinkName,
    partitionKey: partitionKey,
    sequenceNumber: sequenceNumber,
    enqueueSequenceNumber: enqueueSequenceNumber,
    enqueuedTime: enqueuedTime,
    scheduledEnqueueTime: scheduledEnqueueTime,
    offset: offset,
    lockedUntil: lockedUntil,
    partitionIdName: partitionIdName,
    publisher: publisher,
    viaPartitionKey: viaPartitionKey,
    deadLetterSource: deadLetterSource,
    enqueuedTimeAnnotation: enqueuedTimeAnnotation,
    offsetAnnotation: offsetAnnotation,
    sequenceNumberAnnotation: sequenceNumberAnnotation,
    guidSize: guidSize,
    message: message,
    error: error,
    statusCode: statusCode,
    statusDescription: statusDescription,
    errorCondition: errorCondition,
    management: management,
    partition: partition,
    partitionId: partitionId,
    readOperation: readOperation,
    TLS: TLS,
    establishConnection: establishConnection,
    defaultConsumerGroup: defaultConsumerGroup,
    eventHub: eventHub,
    cbsEndpoint: cbsEndpoint,
    cbsReplyTo: cbsReplyTo,
    operationPutToken: operationPutToken,
    aadEventHubsAudience: aadEventHubsAudience,
    aadEventHubsScope: aadEventHubsScope,
    aadServiceBusAudience: aadServiceBusAudience,
    aadServiceBusScope: aadServiceBusScope,
    maxUserAgentLength: maxUserAgentLength,
    vendorString: vendorString,
    attachEpoch: attachEpoch,
    receiverIdentifierName: receiverIdentifierName,
    enableReceiverRuntimeMetricName: enableReceiverRuntimeMetricName,
    timespan: timespan,
    uri: uri,
    dateTimeOffset: dateTimeOffset,
    sessionFilterName: sessionFilterName,
    receiverError: receiverError,
    senderError: senderError,
    sessionError: sessionError,
    connectionError: connectionError,
    defaultOperationTimeoutInMs: defaultOperationTimeoutInMs,
    defaultConnectionIdleTimeoutInMs: defaultConnectionIdleTimeoutInMs,
    managementRequestKey: managementRequestKey,
    negotiateCbsKey: negotiateCbsKey,
    negotiateClaim: negotiateClaim,
    ensureContainerAndBlob: ensureContainerAndBlob,
    defaultPrefetchCount: defaultPrefetchCount,
    reconnectLimit: reconnectLimit,
    maxMessageIdLength: maxMessageIdLength,
    maxPartitionKeyLength: maxPartitionKeyLength,
    maxSessionIdLength: maxSessionIdLength,
    pathDelimiter: pathDelimiter,
    ruleNameMaximumLength: ruleNameMaximumLength,
    maximumSqlFilterStatementLength: maximumSqlFilterStatementLength,
    maximumSqlRuleActionStatementLength: maximumSqlRuleActionStatementLength,
    maxDeadLetterReasonLength: maxDeadLetterReasonLength,
    maxDurationValue: maxDurationValue,
    minDurationValue: minDurationValue,
    maxAbsoluteExpiryTime: maxAbsoluteExpiryTime,
    aadTokenValidityMarginInMs: aadTokenValidityMarginInMs,
    connectionReconnectDelay: connectionReconnectDelay,
    defaultMaxRetries: defaultMaxRetries,
    defaultMaxRetriesForConnection: defaultMaxRetriesForConnection,
    defaultDelayBetweenOperationRetriesInMs: defaultDelayBetweenOperationRetriesInMs,
    defaultMaxDelayForExponentialRetryInMs: defaultMaxDelayForExponentialRetryInMs,
    receiverSettleMode: receiverSettleMode,
    dispositionStatus: dispositionStatus,
    fromSequenceNumber: fromSequenceNumber,
    messageCount: messageCount,
    lockTokens: lockTokens,
    messageIdMapKey: messageIdMapKey,
    sequenceNumberMapKey: sequenceNumberMapKey,
    lockTokenMapKey: lockTokenMapKey,
    sessionIdMapKey: sessionIdMapKey,
    sequenceNumbers: sequenceNumbers,
    deadLetterReason: deadLetterReason,
    deadLetterDescription: deadLetterDescription,
    propertiesToModify: propertiesToModify,
    deadLetterName: deadLetterName,
    trackingId: trackingId,
    serverTimeout: serverTimeout,
    operations: operations,
    descriptorCodes: descriptorCodes
});

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A constant that indicates whether the environment is node.js or browser based.
 */
const isNode = !!process && !!process.version && !!process.versions && !!process.versions.node;
/**
 * Parses the connection string and returns an object of type T.
 *
 * Connection strings have the following syntax:
 *
 * ConnectionString ::= Part { ";" Part } [ ";" ] [ WhiteSpace ]
 * Part             ::= [ PartLiteral [ "=" PartLiteral ] ]
 * PartLiteral      ::= [ WhiteSpace ] Literal [ WhiteSpace ]
 * Literal          ::= ? any sequence of characters except ; or = or WhiteSpace ?
 * WhiteSpace       ::= ? all whitespace characters including \r and \n ?
 *
 * @param {string} connectionString The connection string to be parsed.
 * @returns {ParsedOutput<T>} ParsedOutput<T>.
 */
function parseConnectionString(connectionString) {
    const output = {};
    const parts = connectionString.trim().split(";");
    for (let part of parts) {
        part = part.trim();
        if (part === "") {
            // parts can be empty
            continue;
        }
        const splitIndex = part.indexOf("=");
        if (splitIndex === -1) {
            throw new Error("Connection string malformed: each part of the connection string must have an `=` assignment.");
        }
        const key = part.substring(0, splitIndex).trim();
        if (key === "") {
            throw new Error("Connection string malformed: missing key for assignment");
        }
        const value = part.substring(splitIndex + 1).trim();
        output[key] = value;
    }
    return output;
}
/**
 * Gets a new instance of the async lock with desired settings.
 * @param {AsyncLockOptions} [options] The async lock options.
 * @returns {AsyncLock} AsyncLock
 */
function getNewAsyncLock(options) {
    return new AsyncLock(options);
}
/**
 * @constant {AsyncLock} defaultLock The async lock instance with default settings.
 */
const defaultLock = new AsyncLock({ maxPending: 10000 });
/**
 * Describes a Timeout class that can wait for the specified amount of time and then resolve/reject
 * the promise with the given value.
 * @class Timout
 */
class Timeout {
    set(t, value) {
        return new Promise((resolve, reject) => {
            this.clear();
            const callback = value ? () => reject(new Error(`${value}`)) : resolve;
            this._timer = setTimeout(callback, t);
        });
    }
    clear() {
        if (this._timer) {
            clearTimeout(this._timer);
        }
    }
    wrap(promise, t, value) {
        const wrappedPromise = this._promiseFinally(promise, () => this.clear());
        const timer = this.set(t, value);
        return Promise.race([wrappedPromise, timer]);
    }
    _promiseFinally(promise, fn) {
        const success = (result) => {
            fn();
            return result;
        };
        const error = (e) => {
            fn();
            return Promise.reject(e);
        };
        return Promise.resolve(promise).then(success, error);
    }
    static set(t, value) {
        return new Timeout().set(t, value);
    }
    static wrap(promise, t, value) {
        return new Timeout().wrap(promise, t, value);
    }
}
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param {number} delayInMs - The number of milliseconds to be delayed.
 * @param {AbortSignalLike} abortSignal - The abortSignal associated with containing operation.
 * @param {string} abortErrorMsg - The abort error message associated with containing operation.
 * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
 * @returns {Promise<T>} - Resolved promise
 */
function delay(delayInMs, abortSignal, abortErrorMsg, value) {
    return new Promise((resolve, reject) => {
        const rejectOnAbort = () => {
            return reject(new abortController.AbortError(abortErrorMsg ? abortErrorMsg : `The delay was cancelled by the user.`));
        };
        const removeListeners = () => {
            if (abortSignal) {
                abortSignal.removeEventListener("abort", onAborted);
            }
        };
        const onAborted = () => {
            clearTimeout(timer);
            removeListeners();
            return rejectOnAbort();
        };
        if (abortSignal && abortSignal.aborted) {
            return rejectOnAbort();
        }
        const timer = setTimeout(() => {
            removeListeners();
            resolve(value);
        }, delayInMs);
        if (abortSignal) {
            abortSignal.addEventListener("abort", onAborted);
        }
    });
}
/**
 * Generates a random number between the given interval
 * @param {number} min Min number of the range (inclusive).
 * @param {number} max Max number of the range (inclusive).
 */
function randomNumberFromInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
/*
 * Executes an array of promises sequentially. Inspiration of this method is here:
 * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
 *
 * @param {Array} promiseFactories An array of promise factories(A function that return a promise)
 *
 * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.
 * If not provided then the promise chain starts with undefined.
 *
 * @return A chain of resolved or rejected promises
 */
function executePromisesSequentially(promiseFactories, kickstart) {
    let result = Promise.resolve(kickstart);
    promiseFactories.forEach((promiseFactory) => {
        result = result.then(promiseFactory);
    });
    return result;
}
/**
 * Determines whether the given connection string is an iothub connection string.
 * @param {string} connectionString The connection string.
 * @return {boolean} boolean.
 */
function isIotHubConnectionString(connectionString) {
    connectionString = String(connectionString);
    let result = false;
    const model = parseConnectionString(connectionString);
    if (model && model.HostName && model.SharedAccessKey && model.SharedAccessKeyName) {
        result = true;
    }
    return result;
}
/**
 * @ignore
 * @internal
 */
function isString(s) {
    return typeof s === "string";
}
/**
 * @ignore
 * @internal
 */
function isNumber(n) {
    return typeof n === "number";
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (ConditionStatusMapper) {
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:timeout"] = 408] = "com.microsoft:timeout";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-found"] = 404] = "amqp:not-found";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-implemented"] = 501] = "amqp:not-implemented";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-already-exists"] = 409] = "com.microsoft:entity-already-exists";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:message-lock-lost"] = 410] = "com.microsoft:message-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-lock-lost"] = 410] = "com.microsoft:session-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:no-matching-subscription"] = 500] = "com.microsoft:no-matching-subscription";
    ConditionStatusMapper[ConditionStatusMapper["amqp:link:message-size-exceeded"] = 403] = "amqp:link:message-size-exceeded";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:server-busy"] = 503] = "com.microsoft:server-busy";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-error"] = 400] = "com.microsoft:argument-error";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-out-of-range"] = 400] = "com.microsoft:argument-out-of-range";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:store-lock-lost"] = 410] = "com.microsoft:store-lock-lost";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-cannot-be-locked"] = 410] = "com.microsoft:session-cannot-be-locked";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:partition-not-owned"] = 410] = "com.microsoft:partition-not-owned";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-disabled"] = 400] = "com.microsoft:entity-disabled";
    ConditionStatusMapper[ConditionStatusMapper["com.microsoft:publisher-revoked"] = 401] = "com.microsoft:publisher-revoked";
    ConditionStatusMapper[ConditionStatusMapper["amqp:link:stolen"] = 410] = "amqp:link:stolen";
    ConditionStatusMapper[ConditionStatusMapper["amqp:not-allowed"] = 400] = "amqp:not-allowed";
    ConditionStatusMapper[ConditionStatusMapper["amqp:unauthorized-access"] = 401] = "amqp:unauthorized-access";
    ConditionStatusMapper[ConditionStatusMapper["amqp:resource-limit-exceeded"] = 403] = "amqp:resource-limit-exceeded";
})(exports.ConditionStatusMapper || (exports.ConditionStatusMapper = {}));
(function (ConditionErrorNameMapper) {
    /**
     * Error is thrown when the address is already in use.
     */
    ConditionErrorNameMapper["com.microsoft:address-already-in-use"] = "AddressAlreadyInUseError";
    /**
     * Error is thrown when the store lock is lost.
     */
    ConditionErrorNameMapper["com.microsoft:store-lock-lost"] = "StoreLockLostError";
    /**
     * Error is thrown when a matching subscription is not found.
     */
    ConditionErrorNameMapper["com.microsoft:no-matching-subscription"] = "NoMatchingSubscriptionError";
    /**
     * Error is thrown when an attempt is made to access a parition that is not owned by the
     * requesting entity.
     */
    ConditionErrorNameMapper["com.microsoft:partition-not-owned"] = "PartitionNotOwnedError";
    /**
     * Error is thrown when access to publisher has been revoked.
     */
    ConditionErrorNameMapper["com.microsoft:publisher-revoked"] = "PublisherRevokedError";
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */
    ConditionErrorNameMapper["com.microsoft:entity-already-exists"] = "MessagingEntityAlreadyExistsError";
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */
    ConditionErrorNameMapper["com.microsoft:entity-disabled"] = "MessagingEntityDisabledError";
    /**
     * Error is thrown when the lock on the message is lost.
     */
    ConditionErrorNameMapper["com.microsoft:message-lock-lost"] = "MessageLockLostError";
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */
    ConditionErrorNameMapper["com.microsoft:session-lock-lost"] = "SessionLockLostError";
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */
    ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"] = "SessionCannotBeLockedError";
    /**
     * Error is thrown when an internal server error occured. You may have found a bug?
     */
    ConditionErrorNameMapper["amqp:internal-error"] = "InternalServerError";
    /**
     * Error for signaling general communication errors related to messaging operations.
     */
    ConditionErrorNameMapper["amqp:not-found"] = "ServiceCommunicationError";
    /**
     * Error is thrown when the message is not found.
     */
    ConditionErrorNameMapper["com.microsoft:message-not-found"] = "MessageNotFoundError";
    /**
     * Error is thrown when relay is not found.
     */
    ConditionErrorNameMapper["com.microsoft:relay-not-found"] = "RelayNotFoundError";
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */
    ConditionErrorNameMapper["amqp:not-implemented"] = "NotImplementedError";
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */
    ConditionErrorNameMapper["amqp:not-allowed"] = "InvalidOperationError";
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */
    ConditionErrorNameMapper["amqp:resource-limit-exceeded"] = "QuotaExceededError";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    ConditionErrorNameMapper["amqp:unauthorized-access"] = "UnauthorizedError";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    ConditionErrorNameMapper["com.microsoft:auth-failed"] = "UnauthorizedError";
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */
    ConditionErrorNameMapper["com.microsoft:timeout"] = "ServiceUnavailableError";
    /**
     * Error is thrown when no new messages are received for the specified time.
     */
    ConditionErrorNameMapper["com.microsoft:message-wait-timeout"] = "MessageWaitTimeout";
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */
    ConditionErrorNameMapper["com.microsoft:argument-out-of-range"] = "ArgumentOutOfRangeError";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    ConditionErrorNameMapper["amqp:precondition-failed"] = "PreconditionFailedError";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    ConditionErrorNameMapper["com.microsoft:precondition-failed"] = "PreconditionFailedError";
    /**
     * Error is thrown when data could not be decoded.
     */
    ConditionErrorNameMapper["amqp:decode-error"] = "DecodeError";
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */
    ConditionErrorNameMapper["amqp:invalid-field"] = "InvalidFieldError";
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */
    ConditionErrorNameMapper["amqp:resource-locked"] = "ResourceLockedError";
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */
    ConditionErrorNameMapper["amqp:resource-deleted"] = "ResourceDeletedError";
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */
    ConditionErrorNameMapper["amqp:illegal-state"] = "IllegalStateError";
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */
    ConditionErrorNameMapper["amqp:frame-size-too-small"] = "FrameSizeTooSmallError";
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */
    ConditionErrorNameMapper["amqp:link:detach-forced"] = "DetachForcedError";
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */
    ConditionErrorNameMapper["amqp:link:transfer-limit-exceeded"] = "TransferLimitExceededError";
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */
    ConditionErrorNameMapper["amqp:link:message-size-exceeded"] = "MessageTooLargeError";
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */
    ConditionErrorNameMapper["amqp:link:redirect"] = "LinkRedirectError";
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */
    ConditionErrorNameMapper["amqp:link:stolen"] = "ReceiverDisconnectedError";
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */
    ConditionErrorNameMapper["amqp:session:window-violation"] = "SessionWindowViolationError";
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */
    ConditionErrorNameMapper["amqp:session:errant-link"] = "ErrantLinkError";
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */
    ConditionErrorNameMapper["amqp:session:handle-in-use"] = "HandleInUseError";
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */
    ConditionErrorNameMapper["amqp:session:unattached-handle"] = "UnattachedHandleError";
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */
    ConditionErrorNameMapper["amqp:connection:forced"] = "ConnectionForcedError";
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */
    ConditionErrorNameMapper["amqp:connection:framing-error"] = "FramingError";
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */
    ConditionErrorNameMapper["amqp:connection:redirect"] = "ConnectionRedirectError";
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */
    ConditionErrorNameMapper["com.microsoft:server-busy"] = "ServerBusyError";
    /**
     * Error is thrown when an incorrect argument was received.
     */
    ConditionErrorNameMapper["com.microsoft:argument-error"] = "ArgumentError";
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */
    ConditionErrorNameMapper["com.microsoft:operation-cancelled"] = "OperationCancelledError";
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */
    ConditionErrorNameMapper["client.sender:not-enough-link-credit"] = "SenderBusyError";
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/dist/latest-v8.x/docs/api/all.html#errors_class_system_error}
     */
    ConditionErrorNameMapper["system:error"] = "SystemError";
})(exports.ConditionErrorNameMapper || (exports.ConditionErrorNameMapper = {}));
(function (ErrorNameConditionMapper) {
    /**
     * Error is thrown when the address is already in use.
     */
    ErrorNameConditionMapper["AddressAlreadyInUseError"] = "com.microsoft:address-already-in-use";
    /**
     * Error is thrown when the store lock is lost.
     */
    ErrorNameConditionMapper["StoreLockLostError"] = "com.microsoft:store-lock-lost";
    /**
     * Error is thrown when a matching subscription is not found.
     */
    ErrorNameConditionMapper["NoMatchingSubscriptionError"] = "com.microsoft:no-matching-subscription";
    /**
     * Error is thrown when an attempt is made to access a parition that is not owned by the
     * requesting entity.
     */
    ErrorNameConditionMapper["PartitionNotOwnedError"] = "com.microsoft:partition-not-owned";
    /**
     * Error is thrown when access to publisher has been revoked.
     */
    ErrorNameConditionMapper["PublisherRevokedError"] = "com.microsoft:publisher-revoked";
    /**
     * Error is thrown when an attempt is made to create an entity that already exists.
     */
    ErrorNameConditionMapper["MessagingEntityAlreadyExistsError"] = "com.microsoft:entity-already-exists";
    /**
     * Error is thrown when trying to access/connect to a disabled messaging entity.
     */
    ErrorNameConditionMapper["MessagingEntityDisabledError"] = "com.microsoft:entity-disabled";
    /**
     * Error is thrown when the lock on the message is lost.
     */
    ErrorNameConditionMapper["MessageLockLostError"] = "com.microsoft:message-lock-lost";
    /**
     * Error is thrown when the lock on the Azure ServiceBus session is lost.
     */
    ErrorNameConditionMapper["SessionLockLostError"] = "com.microsoft:session-lock-lost";
    /**
     * Error is thrown when the Azure ServiceBus session cannot be locked.
     */
    ErrorNameConditionMapper["SessionCannotBeLockedError"] = "com.microsoft:session-cannot-be-locked";
    /**
     * Error is thrown when an internal server error occured. You may have found a bug?
     */
    ErrorNameConditionMapper["InternalServerError"] = "amqp:internal-error";
    /**
     * Error for signaling general communication errors related to messaging operations.
     */
    ErrorNameConditionMapper["ServiceCommunicationError"] = "amqp:not-found";
    /**
     * Error is thrown when message is not found.
     */
    ErrorNameConditionMapper["MessageNotFoundError"] = "com.microsoft:message-not-found";
    /**
     * Error is thrown when relay is not found.
     */
    ErrorNameConditionMapper["RelayNotFoundError"] = "com.microsoft:relay-not-found";
    /**
     * Error is thrown when a feature is not implemented yet but the placeholder is present.
     */
    ErrorNameConditionMapper["NotImplementedError"] = "amqp:not-implemented";
    /**
     * Error is thrown when an operation is attempted but is not allowed.
     */
    ErrorNameConditionMapper["InvalidOperationError"] = "amqp:not-allowed";
    /**
     * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
     * Quotas are reset periodically, this operation will have to wait until then.
     * The messaging entity has reached its maximum allowable size.
     * This can happen if the maximum number of receivers (which is 5) has already
     * been opened on a per-consumer group level.
     */
    ErrorNameConditionMapper["QuotaExceededError"] = "amqp:resource-limit-exceeded";
    /**
     * Error is thrown when the connection parameters are wrong and the server refused the connection.
     */
    ErrorNameConditionMapper["UnauthorizedError"] = "amqp:unauthorized-access";
    /**
     * Error is thrown when the service is unavailable. The operation should be retried.
     */
    ErrorNameConditionMapper["ServiceUnavailableError"] = "com.microsoft:timeout";
    /**
     * Error is thrown when no new messages are received for the specified time.
     */
    ErrorNameConditionMapper["MessageWaitTimeout"] = "com.microsoft:message-wait-timeout";
    /**
     * Error is thrown when an argument has a value that is out of the admissible range.
     */
    ErrorNameConditionMapper["ArgumentOutOfRangeError"] = "com.microsoft:argument-out-of-range";
    /**
     * Error is thrown when a condition that should have been met in order to execute an operation was not.
     */
    ErrorNameConditionMapper["PreconditionFailedError"] = "amqp:precondition-failed";
    /**
     * Error is thrown when data could not be decoded.
     */
    ErrorNameConditionMapper["DecodeError"] = "amqp:decode-error";
    /**
     * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
     */
    ErrorNameConditionMapper["InvalidFieldError"] = "amqp:invalid-field";
    /**
     * Error is thrown when the client attempted to work with a server entity to which it
     * has no access because another client is working with it.
     */
    ErrorNameConditionMapper["ResourceLockedError"] = "amqp:resource-locked";
    /**
     * Error is thrown when a server entity the client is working with has been deleted.
     */
    ErrorNameConditionMapper["ResourceDeletedError"] = "amqp:resource-deleted";
    /**
     * Error is thrown when the peer sent a frame that is not permitted in the current state.
     */
    ErrorNameConditionMapper["IllegalStateError"] = "amqp:illegal-state";
    /**
     * Error is thrown when the peer cannot send a frame because the smallest encoding of
     * the performative with the currently valid values would be too large to fit within
     * a frame of the agreed maximum frame size.
     */
    ErrorNameConditionMapper["FrameSizeTooSmallError"] = "amqp:frame-size-too-small";
    /**
     * Error is thrown when an operator intervened to detach for some reason.
     */
    ErrorNameConditionMapper["DetachForcedError"] = "amqp:link:detach-forced";
    /**
     * Error is thrown when the peer sent more message transfers than currently allowed on the link.
     */
    ErrorNameConditionMapper["TransferLimitExceededError"] = "amqp:link:transfer-limit-exceeded";
    /**
     * Error is thrown when the message sent is too large: the maximum size is 256Kb.
     */
    ErrorNameConditionMapper["MessageTooLargeError"] = "amqp:link:message-size-exceeded";
    /**
     * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
     */
    ErrorNameConditionMapper["LinkRedirectError"] = "amqp:link:redirect";
    /**
     * Error is thrown when two or more instances connect to the same partition
     * with different epoch values.
     */
    ErrorNameConditionMapper["ReceiverDisconnectedError"] = "amqp:link:stolen";
    /**
     * Error is thrown when the peer violated incoming window for the session.
     */
    ErrorNameConditionMapper["SessionWindowViolationError"] = "amqp:session:window-violation";
    /**
     * Error is thrown when input was received for a link that was detached with an error.
     */
    ErrorNameConditionMapper["ErrantLinkError"] = "amqp:session:errant-link";
    /**
     * Error is thrown when an attach was received using a handle that is already in use for an attached link.
     */
    ErrorNameConditionMapper["HandleInUseError"] = "amqp:session:handle-in-use";
    /**
     * Error is thrown when a frame (other than attach) was received referencing a handle which is not
     * currently in use of an attached link.
     */
    ErrorNameConditionMapper["UnattachedHandleError"] = "amqp:session:unattached-handle";
    /**
     * Error is thrown when an operator intervened to close the connection for some reason.
     */
    ErrorNameConditionMapper["ConnectionForcedError"] = "amqp:connection:forced";
    /**
     * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
     */
    ErrorNameConditionMapper["FramingError"] = "amqp:connection:framing-error";
    /**
     * Error is thrown when the container is no longer available on the current connection.
     */
    ErrorNameConditionMapper["ConnectionRedirectError"] = "amqp:connection:redirect";
    /**
     * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
     */
    ErrorNameConditionMapper["ServerBusyError"] = "com.microsoft:server-busy";
    /**
     * Error is thrown when an incorrect argument was received.
     */
    ErrorNameConditionMapper["ArgumentError"] = "com.microsoft:argument-error";
    /**
     * Error is thrown when server cancels the operation due to an internal issue.
     */
    ErrorNameConditionMapper["OperationCancelledError"] = "com.microsoft:operation-cancelled";
    /**
     * Error is thrown when the client sender does not have enough link credits to send the message.
     */
    ErrorNameConditionMapper["SenderBusyError"] = "client.sender:not-enough-link-credit";
    /**
     * Error is thrown when a low level system error is thrown by node.js.
     * {@link https://nodejs.org/api/errors.html#errors_class_systemerror}
     */
    ErrorNameConditionMapper["SystemError"] = "system:error";
})(exports.ErrorNameConditionMapper || (exports.ErrorNameConditionMapper = {}));
const systemErrorFieldsToCopy = [
    "address",
    "code",
    "errno",
    "info",
    "port",
    "stack",
    "syscall"
];
/**
 * Describes the base class for Messaging Error.
 * @class {MessagingError}
 * @extends Error
 */
class MessagingError extends Error {
    /**
     * @param {string} message The error message that provides more information about the error.
     * @param originalError An error whose properties will be copied to the MessagingError if the
     * property matches one found on the Node.js `SystemError`.
     */
    constructor(message, originalError) {
        super(message);
        /**
         * @property {string} name The error name. Default value: "MessagingError".
         */
        this.name = "MessagingError";
        /**
         *
         * @property {boolean} retryable Describes whether the error is retryable. Default: true.
         */
        this.retryable = true;
        if (!originalError) {
            return;
        }
        // copy properties from system error
        for (const propName of systemErrorFieldsToCopy) {
            if (originalError[propName] != undefined) {
                this[propName] = originalError[propName];
            }
        }
    }
}
/**
 * Provides a list of retryable AMQP errors.
 * "InternalServerError", "ServerBusyError", "ServiceUnavailableError", "OperationCancelledError",
 * "SenderBusyError", "MessagingError", "DetachForcedError", "ConnectionForcedError",
 * "TransferLimitExceededError"
 */
const retryableErrors = [
    "InternalServerError",
    "ServerBusyError",
    "ServiceUnavailableError",
    "OperationCancelledError",
    // OperationTimeoutError occurs when the service fails to respond within a given timeframe.
    // Since reasons for such failures can be transient, this is treated as a retryable error.
    "OperationTimeoutError",
    "SenderBusyError",
    "MessagingError",
    "DetachForcedError",
    "ConnectionForcedError",
    "TransferLimitExceededError",
    // InsufficientCreditError occurs when the number of credits available on Rhea link is insufficient.
    // Since reasons for such shortage can be transient such as for pending delivery of messages, this is treated as a retryable error.
    "InsufficientCreditError"
];
(function (SystemErrorConditionMapper) {
    SystemErrorConditionMapper["ENOTFOUND"] = "amqp:not-found";
    SystemErrorConditionMapper["EBUSY"] = "com.microsoft:server-busy";
    SystemErrorConditionMapper["ECONNREFUSED"] = "amqp:connection:forced";
    SystemErrorConditionMapper["ETIMEDOUT"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ECONNRESET"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETDOWN"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["EHOSTDOWN"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETRESET"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENETUNREACH"] = "com.microsoft:timeout";
    SystemErrorConditionMapper["ENONET"] = "com.microsoft:timeout";
})(exports.SystemErrorConditionMapper || (exports.SystemErrorConditionMapper = {}));
/**
 * Checks whether the provided error is a node.js SystemError.
 * @param err An object that may contain error information.
 */
function isSystemError(err) {
    if (!err) {
        return false;
    }
    if (!isString(err.code) || !isString(err.syscall)) {
        return false;
    }
    if (!isString(err.errno) && !isNumber(err.errno)) {
        return false;
    }
    return true;
}
/**
 * @internal
 * Since browser doesnt differentiate between the various kinds of service communication errors,
 * this utility is used to look at the error target to identify such category of errors.
 * For more information refer to - https://html.spec.whatwg.org/multipage/comms.html#feedback-from-the-protocol
 * @param err object that may contain error information
 */
function isBrowserWebsocketError(err) {
    let result = false;
    if (!isNode &&
        window &&
        err.type === "error" &&
        err.target instanceof window.WebSocket) {
        result = true;
    }
    return result;
}
const rheaPromiseErrors = [
    // OperationTimeoutError occurs when the service fails to respond within a given timeframe.
    "OperationTimeoutError",
    // InsufficientCreditError occurs when the number of credits available on Rhea link is insufficient.
    "InsufficientCreditError",
    // Defines the error that occurs when the Sender fails to send a message.
    "SendOperationFailedError"
];
/**
 * Translates the AQMP error received at the protocol layer or a SystemError into a MessagingError.
 * All other errors are returned unaltered.
 *
 * @param {AmqpError} err The amqp error that was received.
 * @returns {MessagingError} MessagingError object.
 */
function translate(err) {
    // Built-in errors like TypeError and RangeError should not be retryable as these indicate issues
    // with user input and not an issue with the Messaging process.
    if (err instanceof TypeError || err instanceof RangeError) {
        return err;
    }
    if (isAmqpError(err)) {
        // translate
        const condition = err.condition;
        const description = err.description;
        const error = new MessagingError(description);
        if (err.stack)
            error.stack = err.stack;
        error.info = err.info;
        if (condition) {
            error.code = exports.ConditionErrorNameMapper[condition];
        }
        if (description &&
            (description.includes("status-code: 404") ||
                description.match(/The messaging entity .* could not be found.*/i) !== null)) {
            error.code = "MessagingEntityNotFoundError";
        }
        if (error.code && retryableErrors.indexOf(error.code) === -1) {
            // not found
            error.retryable = false;
        }
        return error;
    }
    if (err.name === "MessagingError") {
        // already translated
        return err;
    }
    if (isSystemError(err)) {
        // translate
        const condition = err.code;
        const description = err.message;
        const error = new MessagingError(description, err);
        let errorType = "SystemError";
        if (condition) {
            const amqpErrorCondition = exports.SystemErrorConditionMapper[condition];
            errorType =
                exports.ConditionErrorNameMapper[amqpErrorCondition];
        }
        if (retryableErrors.indexOf(errorType) === -1) {
            // not found
            error.retryable = false;
        }
        return error;
    }
    if (isBrowserWebsocketError(err)) {
        // Translate browser communication errors during opening handshake to generic SeviceCommunicationError
        const error = new MessagingError("Websocket connection failed.");
        error.code = exports.ConditionErrorNameMapper[exports.ErrorNameConditionMapper.ServiceCommunicationError];
        error.retryable = false;
        return error;
    }
    // Some errors come from rhea-promise and need to be converted to MessagingError.
    // A subset of these are also retryable.
    if (rheaPromiseErrors.indexOf(err.name) !== -1) {
        const error = new MessagingError(err.message, err);
        error.code = err.name;
        if (error.code && retryableErrors.indexOf(error.code) === -1) {
            // not found
            error.retryable = false;
        }
        return error;
    }
    return err;
}
function isAmqpError(error) {
    return rheaPromise.isAmqpError(error);
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The @azure/logger configuration for this package.
 * This will output logs using the `azure:event-hubs` namespace prefix.
 */
const logger = logger$1.createClientLogger("core-amqp");
/**
 * Logs the error's stack trace to "verbose" if a stack trace is available.
 * @param error Error containing a stack trace.
 * @ignore
 */
function logErrorStackTrace(error) {
    if (error && error.stack) {
        logger.verbose(error.stack);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
 * @class RequestResponseLink
 */
class RequestResponseLink {
    /**
     * @constructor
     * @param {Session} session The amqp session.
     * @param {Sender} sender The amqp sender link.
     * @param {Receiver} receiver The amqp receiver link.
     */
    constructor(session, sender, receiver) {
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
    }
    /**
     * Provides the underlying amqp connection object.
     * @returns {Connection} Connection.
     */
    get connection() {
        return this.session.connection;
    }
    /**
     * Indicates whether the session and the sender and receiver links are all open or closed.
     * @returns {boolean} boolean - `true` - `open`, `false` - `closed`.
     */
    isOpen() {
        return this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen();
    }
    /**
     * Sends the given request message and returns the received response. If the operation is not
     * completed in the provided timeout in milliseconds `default: 60000`, then `OperationTimeoutError` is thrown.
     *
     * @param {Message} request The AMQP (request) message.
     * @param {SendRequestOptions} [options] Options that can be provided while sending a request.
     * @returns {Promise<Message>} Promise<Message> The AMQP (response) message.
     */
    sendRequest(request, options = {}) {
        const timeoutInMs = options.timeoutInMs || defaultOperationTimeoutInMs;
        const aborter = options.abortSignal;
        return new Promise((resolve, reject) => {
            let waitTimer;
            let timeOver = false;
            const rejectOnAbort = () => {
                const address = this.receiver.address || "address";
                const requestName = options.requestName;
                const desc = `[${this.connection.id}] The request "${requestName}" ` +
                    `to "${address}" has been cancelled by the user.`;
                // Cancellation is a user-intended action, so log to info instead of warning.
                logger.info(desc);
                const error = new abortController.AbortError(`The ${requestName ? requestName + " " : ""}operation has been cancelled by the user.`);
                reject(error);
            };
            const onAbort = () => {
                // remove the event listener as this will be registered next time someone makes a request.
                this.receiver.removeListener(rheaPromise.ReceiverEvents.message, messageCallback);
                // safe to clear the timeout if it hasn't already occurred.
                if (!timeOver) {
                    clearTimeout(waitTimer);
                }
                aborter.removeEventListener("abort", onAbort);
                rejectOnAbort();
            };
            if (aborter) {
                // the aborter may have been triggered between request attempts
                // so check if it was triggered and reject if needed.
                if (aborter.aborted) {
                    return rejectOnAbort();
                }
                aborter.addEventListener("abort", onAbort);
            }
            // Handle different variations of property names in responses emitted by EventHubs and ServiceBus.
            const getCodeDescriptionAndError = (props) => {
                if (!props)
                    props = {};
                return {
                    statusCode: (props[statusCode] || props.statusCode),
                    statusDescription: (props[statusDescription] ||
                        props.statusDescription),
                    errorCondition: (props[errorCondition] || props.errorCondition)
                };
            };
            const messageCallback = (context) => {
                if (aborter) {
                    aborter.removeEventListener("abort", onAbort);
                }
                const info = getCodeDescriptionAndError(context.message.application_properties);
                const responseCorrelationId = context.message.correlation_id;
                logger.verbose("[%s] %s response: ", this.connection.id, request.to || "$management", context.message);
                if (request.message_id !== responseCorrelationId &&
                    request.correlation_id !== responseCorrelationId) {
                    // do not remove message listener.
                    // parallel requests listen on the same receiver, so continue waiting until respose that matches
                    // request via correlationId is found.
                    logger.verbose("[%s] request-messageId | '%s' != '%s' | response-correlationId. " +
                        "Hence dropping this response and waiting for the next one.", this.connection.id, request.message_id, responseCorrelationId);
                    return;
                }
                // remove the event listeners as they will be registered next time when someone makes a request.
                this.receiver.removeListener(rheaPromise.ReceiverEvents.message, messageCallback);
                if (info.statusCode > 199 && info.statusCode < 300) {
                    if (!timeOver) {
                        clearTimeout(waitTimer);
                    }
                    logger.verbose("[%s] request-messageId | '%s' == '%s' | response-correlationId.", this.connection.id, request.message_id, responseCorrelationId);
                    return resolve(context.message);
                }
                else {
                    const condition = info.errorCondition || exports.ConditionStatusMapper[info.statusCode] || "amqp:internal-error";
                    const e = {
                        condition: condition,
                        description: info.statusDescription
                    };
                    const error = translate(e);
                    logger.warning(error);
                    logErrorStackTrace(error);
                    return reject(error);
                }
            };
            const actionAfterTimeout = () => {
                timeOver = true;
                this.receiver.removeListener(rheaPromise.ReceiverEvents.message, messageCallback);
                if (aborter) {
                    aborter.removeEventListener("abort", onAbort);
                }
                const address = this.receiver.address || "address";
                const desc = `The request with message_id "${request.message_id}" to "${address}" ` +
                    `endpoint timed out. Please try again later.`;
                const e = {
                    name: "OperationTimeoutError",
                    message: desc
                };
                return reject(translate(e));
            };
            waitTimer = setTimeout(actionAfterTimeout, timeoutInMs);
            this.receiver.on(rheaPromise.ReceiverEvents.message, messageCallback);
            logger.verbose("[%s] %s request sent: %O", this.connection.id, request.to || "$managment", request);
            this.sender.send(request);
        });
    }
    /**
     * Closes the sender, receiver link and the underlying session.
     * @returns {Promise<void>} Promise<void>
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.sender.close();
            yield this.receiver.close();
            yield this.session.close();
        });
    }
    /**
     * Removes the sender, receiver link and it's underlying session.
     * @returns {void} void
     */
    remove() {
        this.sender.remove();
        this.receiver.remove();
        this.session.remove();
    }
    /**
     * Creates an amqp request/response link.
     *
     * @param {Connection} connection The amqp connection.
     * @param {SenderOptions} senderOptions Options that must be provided to create the sender link.
     * @param {ReceiverOptions} receiverOptions Options that must be provided to create the receiver link.
     * @returns {Promise<RequestResponseLink>} Promise<RequestResponseLink>
     */
    static create(connection, senderOptions, receiverOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const session = yield connection.createSession();
            const sender = yield session.createSender(senderOptions);
            const receiver = yield session.createReceiver(receiverOptions);
            logger.verbose("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
            return new RequestResponseLink(session, sender, receiver);
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Checks whether a network connection is detected.
 * @ignore
 * @internal
 */
function checkNetworkConnection(host) {
    return new Promise((res) => {
        logger.verbose("Calling dns.resolve to determine network connection status.");
        dns.resolve(host, function (err) {
            if (err) {
                logger.verbose("Error thrown from dns.resolve in network connection check: '%s', %O", err.code || err.name, err);
                // List of possible DNS error codes: https://nodejs.org/dist/latest-v12.x/docs/api/dns.html#dns_error_codes
                // Only when dns.resolve returns an error we expect to see when the network is down, resolve as 'false'.
                if (err.code === dns.CONNREFUSED || err.code === dns.TIMEOUT) {
                    return res(false);
                }
            }
            else {
                logger.verbose("Successfully resolved host via dns.resolve in network connection check.");
            }
            return res(true);
        });
    });
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Determines whether the object is a Delivery object.
 * @ignore
 */
function isDelivery(obj) {
    let result = false;
    if (obj &&
        typeof obj.id === "number" &&
        typeof obj.settled === "boolean" &&
        typeof obj.remote_settled === "boolean" &&
        typeof obj.format === "number") {
        result = true;
    }
    return result;
}
(function (RetryMode) {
    RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
    RetryMode[RetryMode["Fixed"] = 1] = "Fixed";
})(exports.RetryMode || (exports.RetryMode = {}));
(function (RetryOperationType) {
    RetryOperationType["cbsAuth"] = "cbsAuth";
    RetryOperationType["connection"] = "connection";
    RetryOperationType["management"] = "management";
    RetryOperationType["receiverLink"] = "receiverLink";
    RetryOperationType["senderLink"] = "senderLink";
    RetryOperationType["sendMessage"] = "sendMessage";
    RetryOperationType["receiveMessage"] = "receiveMessage";
    RetryOperationType["session"] = "session";
})(exports.RetryOperationType || (exports.RetryOperationType = {}));
/**
 * Validates the retry config.
 * @ignore
 */
function validateRetryConfig(config) {
    if (!config.operation) {
        throw new TypeError("Missing 'operation' in retry configuration");
    }
    if (!config.connectionId) {
        throw new TypeError("Missing 'connectionId' in retry configuration");
    }
    if (!config.operationType) {
        throw new TypeError("Missing 'operationType' in retry configuration");
    }
}
/**
 * Every operation is attempted at least once. Additional attempts are made if the previous attempt failed
 * with a retryable error. The number of additional attempts is governed by the `maxRetries` property provided
 * on the `RetryConfig` argument.
 *
 * If `mode` option is set to `Fixed`, then the retries are made on the
 * given operation for a specified number of times, with a fixed delay in between each retry each time.
 *
 * If `mode` option is set to `Exponential`, then the delay between retries is adjusted to increase
 * exponentially with each attempt using back-off factor of power 2.
 *
 * @param {RetryConfig<T>} config Parameters to configure retry operation
 *
 * @return {Promise<T>} Promise<T>.
 */
function retry(config) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        validateRetryConfig(config);
        if (!config.retryOptions) {
            config.retryOptions = {};
        }
        if (config.retryOptions.maxRetries == undefined || config.retryOptions.maxRetries < 0) {
            config.retryOptions.maxRetries = defaultMaxRetries;
        }
        if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) {
            config.retryOptions.retryDelayInMs = defaultDelayBetweenOperationRetriesInMs;
        }
        if (config.retryOptions.maxRetryDelayInMs == undefined ||
            config.retryOptions.maxRetryDelayInMs < 0) {
            config.retryOptions.maxRetryDelayInMs = defaultMaxDelayForExponentialRetryInMs;
        }
        if (config.retryOptions.mode == undefined) {
            config.retryOptions.mode = exports.RetryMode.Fixed;
        }
        let lastError;
        let result;
        let success = false;
        const totalNumberOfAttempts = config.retryOptions.maxRetries + 1;
        for (let i = 1; i <= totalNumberOfAttempts; i++) {
            logger.verbose("[%s] Attempt number: %d", config.connectionId, config.operationType, i);
            try {
                result = yield config.operation();
                success = true;
                logger.verbose("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, i);
                if (result && !isDelivery(result)) {
                    logger.verbose("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
                }
                break;
            }
            catch (err) {
                if (!err.translated) {
                    err = translate(err);
                }
                if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
                    const isConnected = yield checkNetworkConnection(config.connectionHost);
                    if (!isConnected) {
                        err.name = "ConnectionLostError";
                        err.retryable = true;
                    }
                }
                lastError = err;
                logger.verbose("[%s] Error occured for '%s' in attempt number %d: %O", config.connectionId, config.operationType, i, err);
                let targetDelayInMs = config.retryOptions.retryDelayInMs;
                if (config.retryOptions.mode === exports.RetryMode.Exponential) {
                    let incrementDelta = Math.pow(2, i) - 1;
                    const boundedRandDelta = config.retryOptions.retryDelayInMs * 0.8 +
                        Math.floor(Math.random() *
                            (config.retryOptions.retryDelayInMs * 1.2 - config.retryOptions.retryDelayInMs * 0.8));
                    incrementDelta *= boundedRandDelta;
                    targetDelayInMs = Math.min(incrementDelta, config.retryOptions.maxRetryDelayInMs);
                }
                if (lastError && lastError.retryable) {
                    logger.verbose("[%s] Sleeping for %d milliseconds for '%s'.", config.connectionId, targetDelayInMs, config.operationType);
                    yield delay(targetDelayInMs, config.abortSignal, `The retry operation has been cancelled by the user.`);
                    continue;
                }
                else {
                    break;
                }
            }
        }
        if (success) {
            return result;
        }
        else {
            throw lastError;
        }
    });
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * The default data transformer that will be used by the Azure SDK.
 */
class DefaultDataTransformer {
    /**
     * A function that takes the body property from an EventData object
     * and returns an encoded body (some form of AMQP type).
     *
     * @param {*} body The AMQP message body
     * @return {DataSection} encodedBody - The encoded AMQP message body as an AMQP Data type
     * (data section in rhea terms). Section object with following properties:
     * - typecode: 117 (0x75)
     * - content: The given AMQP message body as a Buffer.
     * - multiple: true | undefined.
     */
    encode(body) {
        let result;
        if (isBuffer(body)) {
            result = rheaPromise.message.data_section(body);
        }
        else {
            // string, undefined, null, boolean, array, object, number should end up here
            // coercing undefined to null as that will ensure that null value will be given to the
            // customer on receive.
            if (body === undefined)
                body = null; // tslint:disable-line
            try {
                const bodyStr = JSON.stringify(body);
                result = rheaPromise.message.data_section(buffer.Buffer.from(bodyStr, "utf8"));
            }
            catch (err) {
                const msg = `An error occurred while executing JSON.stringify() on the given body ` +
                    body +
                    `${err ? err.stack : JSON.stringify(err)}`;
                logger.warning("[encode] " + msg);
                logErrorStackTrace(err);
                throw new Error(msg);
            }
        }
        return result;
    }
    /**
     * @property {Function} [decode] A function that takes the body property from an AMQP message
     * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.
     * If it cannot decode the body then it returns the body
     * as-is.
     * @param {DataSection} body The AMQP message body
     * @return {*} decoded body or the given body as-is.
     */
    decode(body) {
        let processedBody = body;
        try {
            if (body.content && isBuffer(body.content)) {
                // This indicates that we are getting the AMQP described type. Let us try decoding it.
                processedBody = body.content;
            }
            try {
                // Trying to stringify and JSON.parse() anything else will fail flat and we shall return
                // the original type back
                const bodyStr = processedBody.toString("utf8");
                processedBody = JSON.parse(bodyStr);
            }
            catch (err) {
                logger.verbose("[decode] An error occurred while trying JSON.parse() on the received body. " +
                    "The error is %O", err);
            }
        }
        catch (err) {
            logger.verbose("[decode] An error occurred while decoding the received message body. The error is: %O", err);
        }
        return processedBody;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (TokenType) {
    /**
     * The "jwt" token type. Used with AADTokenCredential.
     */
    TokenType["CbsTokenTypeJwt"] = "jwt";
    /**
     * The sas token type. Used with SharedKeyCredential.
     */
    TokenType["CbsTokenTypeSas"] = "servicebus.windows.net:sastoken";
})(exports.TokenType || (exports.TokenType = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class SharedKeyCredential
 * Defines the SharedKeyCredential .
 */
class SharedKeyCredential {
    /**
     * Initializes a new instance of SharedKeyCredential
     * @constructor
     * @param {string} keyName - The name of the EventHub/ServiceBus key.
     * @param {string} key - The secret value associated with the above EventHub/ServiceBus key
     */
    constructor(keyName, key) {
        this.keyName = keyName;
        this.key = key;
    }
    /**
     * Gets the sas token for the specified audience
     * @param {string} [audience] - The audience for which the token is desired.
     */
    getToken(audience) {
        return this._createToken(Math.floor(Date.now() / 1000) + 3600, audience);
    }
    /**
     * @protected
     * Creates the sas token based on the provided information
     * @param {string | number} expiry - The time period in unix time after which the token will expire.
     * @param {string} [audience] - The audience for which the token is desired.
     * @param {string | Buffer} [hashInput] The input to be provided to hmac to create the hash.
     */
    _createToken(expiry, audience, hashInput) {
        audience = encodeURIComponent(audience);
        const keyName = encodeURIComponent(this.keyName);
        const stringToSign = audience + "\n" + expiry;
        hashInput = hashInput || this.key;
        let shaObj;
        if (isBuffer(hashInput)) {
            shaObj = new jssha("SHA-256", "ARRAYBUFFER");
            shaObj.setHMACKey(hashInput, "ARRAYBUFFER");
            shaObj.update(buffer.Buffer.from(stringToSign));
        }
        else {
            shaObj = new jssha("SHA-256", "TEXT");
            shaObj.setHMACKey(hashInput, "TEXT");
            shaObj.update(stringToSign);
        }
        const sig = encodeURIComponent(shaObj.getHMAC("B64"));
        return {
            token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,
            expiresOnTimestamp: expiry
        };
    }
    /**
     * Creates a token provider from the EventHub/ServiceBus connection string;
     * @param {string} connectionString - The EventHub/ServiceBus connection string
     */
    static fromConnectionString(connectionString) {
        const parsed = parseConnectionString(connectionString);
        return new SharedKeyCredential(parsed.SharedAccessKeyName, parsed.SharedAccessKey);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class IotSharedKeyCredential
 * @ignore
 * Defines the IotSharedKeyCredential for IotHub.
 */
class IotSharedKeyCredential extends SharedKeyCredential {
    /**
     * Gets the sas token for the specified audience for IotHub.
     * @ignore
     * @param {string} [audience] - The audience for which the token is desired. If not
     * provided then the Endpoint from the connection string will be applied.
     */
    getToken(audience) {
        return this._createToken(Math.floor(Date.now() / 1000) + 3600, audience, buffer.Buffer.from(this.key, "base64"));
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (ConnectionConfig) {
    /**
     * Creates the connection config.
     * @param {string} connectionString - The connection string for a given service like
     * EventHub/ServiceBus.
     * @param {string} [path]           - The name/path of the entity (hub name) to which the
     * connection needs to happen. This will override the EntityPath in the connectionString
     * if present.
     * @returns {ConnectionConfig} ConnectionConfig
     */
    function create(connectionString, path) {
        connectionString = String(connectionString);
        const parsedCS = parseConnectionString(connectionString);
        if (!parsedCS.Endpoint) {
            throw new TypeError("Missing Endpoint in Connection String.");
        }
        if (!parsedCS.Endpoint.endsWith("/"))
            parsedCS.Endpoint += "/";
        const result = {
            connectionString: connectionString,
            endpoint: parsedCS.Endpoint,
            host: parsedCS && parsedCS.Endpoint ? (parsedCS.Endpoint.match("sb://([^/]*)") || [])[1] : "",
            sharedAccessKeyName: parsedCS.SharedAccessKeyName,
            sharedAccessKey: parsedCS.SharedAccessKey
        };
        if (path || parsedCS.EntityPath) {
            result.entityPath = path || parsedCS.EntityPath;
        }
        return result;
    }
    ConnectionConfig.create = create;
    /**
     * Validates the properties of connection config.
     * @param {ConnectionConfig} config The connection config to be validated.
     * @returns {void} void
     */
    function validate(config, options) {
        if (!options)
            options = {};
        if (!config) {
            throw new TypeError("Missing configuration");
        }
        if (!config.endpoint) {
            throw new TypeError("Missing 'endpoint' in configuration");
        }
        config.endpoint = String(config.endpoint);
        if (!config.host) {
            throw new TypeError("Missing 'host' in configuration");
        }
        config.host = String(config.host);
        if (options.isEntityPathRequired && !config.entityPath) {
            throw new TypeError("Missing 'entityPath' in configuration");
        }
        config.entityPath = String(config.entityPath);
        if (!config.sharedAccessKeyName) {
            throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
        }
        config.sharedAccessKeyName = String(config.sharedAccessKeyName);
        if (!config.sharedAccessKey) {
            throw new TypeError("Missing 'sharedAccessKey' in configuration");
        }
        config.sharedAccessKey = String(config.sharedAccessKey);
    }
    ConnectionConfig.validate = validate;
})(exports.ConnectionConfig || (exports.ConnectionConfig = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (EventHubConnectionConfig) {
    /**
     * Creates the connection config.
     * @param {string} connectionString - The connection string for a given service like
     * EventHub/ServiceBus.
     * @param {string} [path]           - The name/path of the entity (hub name) to which the
     * connection needs to happen. This will override the EntityPath in the connectionString
     * if present.
     * @returns {EventHubConnectionConfig} EventHubConnectionConfig
     */
    function create(connectionString, path) {
        const config = exports.ConnectionConfig.create(connectionString, path);
        if (!config.entityPath) {
            throw new TypeError(`Either provide "path" or the "connectionString": "${connectionString}", ` +
                `must contain EntityPath="<path-to-the-entity>".`);
        }
        return createFromConnectionConfig(config);
    }
    EventHubConnectionConfig.create = create;
    /**
     * Creates an EventHubConnectionConfig from the provided base ConnectionConfig.
     * @param config The base connection config from which the EventHubConnectionConfig needs to be
     * created.
     * @returns EventHubConnectionConfig
     */
    function createFromConnectionConfig(config) {
        exports.ConnectionConfig.validate(config, { isEntityPathRequired: true });
        config.getManagementAudience = () => {
            return `${config.endpoint}${config.entityPath}/$management`;
        };
        config.getManagementAddress = () => {
            return `${config.entityPath}/$management`;
        };
        config.getSenderAudience = (partitionId) => {
            if (partitionId != undefined) {
                return `${config.endpoint}${config.entityPath}/Partitions/${partitionId}`;
            }
            else {
                return `${config.endpoint}${config.entityPath}`;
            }
        };
        config.getSenderAddress = (partitionId) => {
            if (partitionId != undefined) {
                return `${config.entityPath}/Partitions/${partitionId}`;
            }
            else {
                return `${config.entityPath}`;
            }
        };
        config.getReceiverAudience = (partitionId, consumergroup) => {
            if (!consumergroup)
                consumergroup = "$default";
            return (`${config.endpoint}${config.entityPath}/ConsumerGroups/${consumergroup}/` +
                `Partitions/${partitionId}`);
        };
        config.getReceiverAddress = (partitionId, consumergroup) => {
            if (!consumergroup)
                consumergroup = "$default";
            return `${config.entityPath}/ConsumerGroups/${consumergroup}/Partitions/${partitionId}`;
        };
        return config;
    }
    EventHubConnectionConfig.createFromConnectionConfig = createFromConnectionConfig;
    /**
     * Validates the properties of connection config.
     * @param {ConnectionConfig} config The connection config to be validated.
     * @returns {void} void
     */
    function validate(config) {
        return exports.ConnectionConfig.validate(config, { isEntityPathRequired: true });
    }
    EventHubConnectionConfig.validate = validate;
})(exports.EventHubConnectionConfig || (exports.EventHubConnectionConfig = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (IotHubConnectionConfig) {
    /**
     * Creates the connection config.
     * @ignore
     * @param {string} connectionString - The event hub connection string
     * @param {string} [path]           - The name/path of the entity (hub name) to which the connection needs to happen
     */
    function create(connectionString, path) {
        connectionString = String(connectionString);
        const parsedCS = parseConnectionString(connectionString);
        if (!path) {
            path = "messages/events";
        }
        const result = {
            connectionString: connectionString,
            hostName: parsedCS.HostName,
            host: parsedCS && parsedCS.HostName ? parsedCS.HostName.split(".")[0] : "",
            entityPath: path,
            sharedAccessKeyName: parsedCS.SharedAccessKeyName,
            sharedAccessKey: parsedCS.SharedAccessKey,
            deviceId: parsedCS.DeviceId
        };
        return result;
    }
    IotHubConnectionConfig.create = create;
    /**
     * Validates the properties of connection config.
     * @ignore
     * @param {ConnectionConfig} config The connection config to be validated.
     */
    function validate(config) {
        if (!config) {
            throw new TypeError("Missing configuration");
        }
        if (!config.hostName) {
            throw new TypeError("Missing 'hostName' in configuration");
        }
        config.hostName = String(config.hostName);
        if (!config.entityPath) {
            throw new TypeError("Missing 'entityPath' in configuration");
        }
        config.entityPath = String(config.entityPath);
        if (!config.sharedAccessKeyName) {
            throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
        }
        config.sharedAccessKeyName = String(config.sharedAccessKeyName);
        if (!config.sharedAccessKey) {
            throw new TypeError("Missing 'sharedAccessKey' in configuration");
        }
        config.sharedAccessKey = String(config.sharedAccessKey);
        if (config.deviceId) {
            config.deviceId = String(config.deviceId);
        }
    }
    IotHubConnectionConfig.validate = validate;
    /**
     * Convert iothub connection config to eventhub connection config.
     * @ignore
     * @param {IotHubConnectionConfig} iotHubConfig
     */
    function convertToEventHubConnectionConfig(iotHubConfig) {
        validate(iotHubConfig);
        const config = {
            sharedAccessKey: iotHubConfig.sharedAccessKey,
            sharedAccessKeyName: iotHubConfig.sharedAccessKeyName,
            entityPath: iotHubConfig.entityPath,
            host: iotHubConfig.hostName,
            endpoint: `sb://${iotHubConfig.hostName}/`,
            connectionString: iotHubConfig.connectionString
        };
        return exports.EventHubConnectionConfig.createFromConnectionConfig(config);
    }
    IotHubConnectionConfig.convertToEventHubConnectionConfig = convertToEventHubConnectionConfig;
})(exports.IotHubConnectionConfig || (exports.IotHubConnectionConfig = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class CbsClient
 * Describes the EventHub/ServiceBus Cbs client that talks to the $cbs endopint over AMQP connection.
 */
class CbsClient {
    /**
     * @constructor
     * @param {Connection} connection The AMQP conection.
     * @param {string} connectionLock A unique string (usually a guid) per connection.
     */
    constructor(connection, connectionLock) {
        /**
         * @property {string} endpoint CBS endpoint - "$cbs"
         */
        this.endpoint = cbsEndpoint;
        /**
         * @property {string} replyTo CBS replyTo - The reciever link name that the service should reply to.
         */
        this.replyTo = `${cbsReplyTo}-${rheaPromise.generate_uuid()}`;
        /**
         * @property {string} cbsLock The unqiue lock name per $cbs session per connection that is used to
         * acquire the lock for establishing a cbs session if one does not exist for an aqmp connection.
         */
        this.cbsLock = `${negotiateCbsKey}-${rheaPromise.generate_uuid()}`;
        this.connection = connection;
        this.connectionLock = connectionLock;
    }
    /**
     * Creates a singleton instance of the CBS session if it hasn't been initialized previously on
     * the given connection.
     * @returns {Promise<void>} Promise<void>.
     */
    init() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                // Acquire the lock and establish an amqp connection if it does not exist.
                if (!this.connection.isOpen()) {
                    logger.verbose("The CBS client is trying to establish an AMQP connection.");
                    yield defaultLock.acquire(this.connectionLock, () => {
                        return this.connection.open();
                    });
                }
                if (!this._isCbsSenderReceiverLinkOpen()) {
                    const rxOpt = {
                        source: {
                            address: this.endpoint
                        },
                        name: this.replyTo,
                        onSessionError: (context) => {
                            const id = context.connection.options.id;
                            const ehError = translate(context.session.error);
                            logger.verbose("[%s] An error occurred on the session for request/response links " + "for $cbs: %O", id, ehError);
                        }
                    };
                    const srOpt = { target: { address: this.endpoint } };
                    logger.verbose("[%s] Creating sender/receiver links on a session for $cbs endpoint.", this.connection.id);
                    this._cbsSenderReceiverLink = yield RequestResponseLink.create(this.connection, srOpt, rxOpt);
                    this._cbsSenderReceiverLink.sender.on(rheaPromise.SenderEvents.senderError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = translate(context.sender.error);
                        logger.verbose("[%s] An error occurred on the cbs sender link.. %O", id, ehError);
                    });
                    this._cbsSenderReceiverLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = translate(context.receiver.error);
                        logger.verbose("[%s] An error occurred on the cbs receiver link.. %O", id, ehError);
                    });
                    logger.verbose("[%s] Successfully created the cbs sender '%s' and receiver '%s' " +
                        "links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
                }
                else {
                    logger.verbose("[%s] CBS session is already present. Reusing the cbs sender '%s' " +
                        "and receiver '%s' links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
                }
            }
            catch (err) {
                err = translate(err);
                logger.warning("[%s] An error occured while establishing the cbs links: %O", this.connection.id, err);
                logErrorStackTrace(err);
                throw err;
            }
        });
    }
    /**
     * Negotiates the CBS claim with the EventHub/ServiceBus Service.
     * @param {string} audience The entity token audience for which the token is requested in one
     * of the following forms:
     *
     * - **ServiceBus**
     *    - **Sender**
     *        - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *        - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **Receiver**
     *         - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
     *         - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
     *
     *    - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management"`.
     *         - `"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management"`.
     *
     * - **EventHubs**
     *     - **Sender**
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
     *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
     *
     *     - **Receiver**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
     *
     *     - **ManagementClient**
     *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
     * @param {TokenInfo} tokenObject The token object that needs to be sent in the put-token request.
     * @return {Promise<any>} Returns a Promise that resolves when $cbs authentication is successful
     * and rejects when an error occurs during $cbs authentication.
     */
    negotiateClaim(audience, tokenObject, tokenType) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const request = {
                    body: tokenObject.token,
                    message_id: rheaPromise.generate_uuid(),
                    reply_to: this.replyTo,
                    to: this.endpoint,
                    application_properties: {
                        operation: operationPutToken,
                        name: audience,
                        type: tokenType
                    }
                };
                const responseMessage = yield this._cbsSenderReceiverLink.sendRequest(request);
                logger.verbose("[%s] The CBS response is: %O", this.connection.id, responseMessage);
                return this._fromAmqpMessageResponse(responseMessage);
            }
            catch (err) {
                logger.warning("[%s] An error occurred while negotiating the cbs claim: %O", this.connection.id, err);
                logErrorStackTrace(err);
                throw err;
            }
        });
    }
    /**
     * Closes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @return {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._isCbsSenderReceiverLinkOpen()) {
                    const cbsLink = this._cbsSenderReceiverLink;
                    this._cbsSenderReceiverLink = undefined;
                    yield cbsLink.close();
                    logger.verbose("[%s] Successfully closed the cbs session.", this.connection.id);
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the cbs link: ${err.stack ||
                    JSON.stringify(err)}.`;
                logger.verbose("[%s] %s", this.connection.id, msg);
                throw new Error(msg);
            }
        });
    }
    /**
     * Removes the AMQP cbs session to the EventHub/ServiceBus for this client,
     * @returns {void} void
     */
    remove() {
        try {
            if (this._cbsSenderReceiverLink) {
                const cbsLink = this._cbsSenderReceiverLink;
                this._cbsSenderReceiverLink = undefined;
                cbsLink.remove();
                logger.verbose("[%s] Successfully removed the cbs session.", this.connection.id);
            }
        }
        catch (err) {
            const msg = `An error occurred while removing the cbs link: ${err.stack ||
                JSON.stringify(err)}.`;
            logger.verbose("[%s] %s", this.connection.id, msg);
            throw new Error(msg);
        }
    }
    /**
     * Indicates whether the cbs sender receiver link is open or closed.
     * @private
     * @return {boolean} `true` open, `false` closed.
     */
    _isCbsSenderReceiverLinkOpen() {
        return this._cbsSenderReceiverLink && this._cbsSenderReceiverLink.isOpen();
    }
    _fromAmqpMessageResponse(msg) {
        const cbsResponse = {
            correlationId: msg.correlation_id,
            statusCode: msg.application_properties ? msg.application_properties["status-code"] : "",
            satusDescription: msg.application_properties
                ? msg.application_properties["status-description"]
                : ""
        };
        logger.verbose("[%s] The deserialized CBS response is: %o", this.connection.id, cbsResponse);
        return cbsResponse;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (MessageHeader) {
    /**
     * Converts MessageHeader to AmqpMessageHeader.
     *
     * @param {MessageHeader} props Message header.
     * @returns {AmqpMessageHeader} AmqpMessageHeader
     */
    function toAmqpMessageHeader(props) {
        const amqpHeader = {};
        if (props.deliveryCount != undefined) {
            amqpHeader.delivery_count = props.deliveryCount;
        }
        if (props.durable != undefined)
            amqpHeader.durable = props.durable;
        if (props.firstAcquirer != undefined) {
            amqpHeader.first_acquirer = props.firstAcquirer;
        }
        if (props.priority != undefined) {
            amqpHeader.priority = props.priority;
        }
        if (props.ttl != undefined) {
            amqpHeader.ttl = props.ttl;
        }
        logger.verbose("To AmqpMessageHeader: %O", amqpHeader);
        return amqpHeader;
    }
    MessageHeader.toAmqpMessageHeader = toAmqpMessageHeader;
    /**
     * Converts AmqpMessageHeader to MessageHeader.
     *
     * @param {AmqpMessageHeader} props Amqp Message Header
     * @returns {MessageHeader} MessageHeader.
     */
    function fromAmqpMessageHeader(props) {
        const msgHeader = {};
        if (props.delivery_count != undefined) {
            msgHeader.deliveryCount = props.delivery_count;
        }
        if (props.durable != undefined) {
            msgHeader.durable = props.durable;
        }
        if (props.first_acquirer != undefined) {
            msgHeader.firstAcquirer = props.first_acquirer;
        }
        if (props.priority != undefined) {
            msgHeader.priority = props.priority;
        }
        if (props.ttl != undefined) {
            msgHeader.ttl = props.ttl;
        }
        logger.verbose("From AmqpMessageHeader: %O", msgHeader);
        return msgHeader;
    }
    MessageHeader.fromAmqpMessageHeader = fromAmqpMessageHeader;
})(exports.MessageHeader || (exports.MessageHeader = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (MessageProperties) {
    /**
     * Converts MessageProperties to AmqpMessageProperties.
     * @param {MessageProperties} props Message properties.
     * @returns {AmqpMessageProperties} AmqpMessageProperties.
     */
    function toAmqpMessageProperties(props) {
        const amqpProperties = {};
        if (props.absoluteExpiryTime != undefined) {
            amqpProperties.absolute_expiry_time = props.absoluteExpiryTime;
        }
        if (props.contentEncoding != undefined) {
            amqpProperties.content_encoding = props.contentEncoding;
        }
        if (props.contentType != undefined) {
            amqpProperties.content_type = props.contentType;
        }
        if (props.correlationId != undefined) {
            amqpProperties.correlation_id = props.correlationId;
        }
        if (props.creationTime != undefined) {
            amqpProperties.creation_time = props.creationTime;
        }
        if (props.groupId != undefined) {
            amqpProperties.group_id = props.groupId;
        }
        if (props.groupSequence != undefined) {
            amqpProperties.group_sequence = props.groupSequence;
        }
        if (props.messageId != undefined) {
            amqpProperties.message_id = props.messageId;
        }
        if (props.replyTo != undefined) {
            amqpProperties.reply_to = props.replyTo;
        }
        if (props.replyToGroupId != undefined) {
            amqpProperties.reply_to_group_id = props.replyToGroupId;
        }
        if (props.subject != undefined) {
            amqpProperties.subject = props.subject;
        }
        if (props.to != undefined) {
            amqpProperties.to = props.to;
        }
        if (props.userId != undefined) {
            amqpProperties.user_id = props.userId;
        }
        logger.verbose("To AmqpMessageProperties: %O", amqpProperties);
        return amqpProperties;
    }
    MessageProperties.toAmqpMessageProperties = toAmqpMessageProperties;
    /**
     * Converts AmqpMessageProperties to MessageProperties.
     * @param {AmqpMessageProperties} props Amqp message properties.
     * @returns {MessageProperties} MessageProperties.
     */
    function fromAmqpMessageProperties(props) {
        const msgProperties = {};
        if (props.absolute_expiry_time != undefined) {
            msgProperties.absoluteExpiryTime = props.absolute_expiry_time;
        }
        if (props.content_encoding != undefined) {
            msgProperties.contentEncoding = props.content_encoding;
        }
        if (props.content_type != undefined) {
            msgProperties.contentType = props.content_type;
        }
        if (props.correlation_id != undefined) {
            msgProperties.correlationId = props.correlation_id;
        }
        if (props.creation_time != undefined) {
            msgProperties.creationTime = props.creation_time;
        }
        if (props.group_id != undefined) {
            msgProperties.groupId = props.group_id;
        }
        if (props.group_sequence != undefined) {
            msgProperties.groupSequence = props.group_sequence;
        }
        if (props.message_id != undefined) {
            msgProperties.messageId = props.message_id;
        }
        if (props.reply_to != undefined) {
            msgProperties.replyTo = props.reply_to;
        }
        if (props.reply_to_group_id != undefined) {
            msgProperties.replyToGroupId = props.reply_to_group_id;
        }
        if (props.subject != undefined) {
            msgProperties.subject = props.subject;
        }
        if (props.to != undefined) {
            msgProperties.to = props.to;
        }
        if (props.user_id != undefined) {
            msgProperties.userId = props.user_id;
        }
        logger.verbose("From AmqpMessageProperties: %O", msgProperties);
        return msgProperties;
    }
    MessageProperties.fromAmqpMessageProperties = fromAmqpMessageProperties;
})(exports.MessageProperties || (exports.MessageProperties = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Returns information about the platform this function is being run on.
 * @ignore
 * @internal
 */
function getPlatformInfo() {
    return `(${os.arch()}-${os.type()}-${os.release()})`;
}
/**
 * Returns information about Node.js this function is being run on.
 * @ignore
 * @internal
 */
function getFrameworkInfo() {
    return `Node/${process.version}`;
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (ConnectionContextBase) {
    /**
     * Creates the base connection context.
     * @param {CreateConnectionContextBaseParameters} parameters Parameters to be provided to create
     * the base connection context.
     */
    function create(parameters) {
        exports.ConnectionConfig.validate(parameters.config, {
            isEntityPathRequired: parameters.isEntityPathRequired || false
        });
        const userAgent = parameters.connectionProperties.userAgent;
        if (userAgent.length > maxUserAgentLength) {
            throw new Error(`The user-agent string cannot be more than ${maxUserAgentLength} characters in length.` +
                `The given user-agent string is: ${userAgent} with length: ${userAgent.length}`);
        }
        const connectionOptions = {
            transport: TLS,
            host: parameters.config.host,
            hostname: parameters.config.host,
            username: parameters.config.sharedAccessKeyName,
            port: 5671,
            reconnect: false,
            properties: {
                product: parameters.connectionProperties.product,
                version: parameters.connectionProperties.version,
                "user-agent": userAgent,
                platform: getPlatformInfo(),
                framework: getFrameworkInfo()
            },
            idle_time_out: defaultConnectionIdleTimeoutInMs,
            operationTimeoutInSeconds: parameters.operationTimeoutInMs
                ? parameters.operationTimeoutInMs / 1000
                : undefined
        };
        if (parameters.config.webSocket ||
            (!isNode && typeof window !== "undefined" && window.WebSocket)) {
            const socket = parameters.config.webSocket || window.WebSocket;
            const host = parameters.config.host;
            const endpoint = parameters.config.webSocketEndpointPath || "";
            const socketOptions = parameters.config.webSocketConstructorOptions || {};
            connectionOptions.webSocketOptions = {
                webSocket: socket,
                url: `wss://${host}:443/${endpoint}`,
                protocol: ["AMQPWSB10"],
                options: socketOptions
            };
        }
        const connection = new rheaPromise.Connection(connectionOptions);
        const connectionLock = `${establishConnection}-${rheaPromise.generate_uuid()}`;
        const connectionContextBase = {
            wasConnectionCloseCalled: false,
            connectionLock: connectionLock,
            negotiateClaimLock: `${negotiateClaim}-${rheaPromise.generate_uuid()}`,
            connection: connection,
            connectionId: connection.id,
            cbsSession: new CbsClient(connection, connectionLock),
            config: parameters.config,
            tokenCredential: parameters.tokenCredential ||
                new SharedKeyCredential(parameters.config.sharedAccessKeyName, parameters.config.sharedAccessKey),
            dataTransformer: parameters.dataTransformer || new DefaultDataTransformer()
        };
        return connectionContextBase;
    }
    ConnectionContextBase.create = create;
})(exports.ConnectionContextBase || (exports.ConnectionContextBase = {}));

Object.defineProperty(exports, 'isAmqpError', {
    enumerable: true,
    get: function () {
        return rheaPromise.isAmqpError;
    }
});
exports.AsyncLock = AsyncLock;
Object.defineProperty(exports, 'isTokenCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.isTokenCredential;
    }
});
exports.CbsClient = CbsClient;
exports.Constants = constants;
exports.DefaultDataTransformer = DefaultDataTransformer;
exports.IotSharedKeyCredential = IotSharedKeyCredential;
exports.MessagingError = MessagingError;
exports.RequestResponseLink = RequestResponseLink;
exports.SharedKeyCredential = SharedKeyCredential;
exports.Timeout = Timeout;
exports.defaultLock = defaultLock;
exports.delay = delay;
exports.executePromisesSequentially = executePromisesSequentially;
exports.getNewAsyncLock = getNewAsyncLock;
exports.isIotHubConnectionString = isIotHubConnectionString;
exports.isNode = isNode;
exports.isSystemError = isSystemError;
exports.logger = logger;
exports.parseConnectionString = parseConnectionString;
exports.randomNumberFromInterval = randomNumberFromInterval;
exports.retry = retry;
exports.retryableErrors = retryableErrors;
exports.translate = translate;
//# sourceMappingURL=index.js.map
