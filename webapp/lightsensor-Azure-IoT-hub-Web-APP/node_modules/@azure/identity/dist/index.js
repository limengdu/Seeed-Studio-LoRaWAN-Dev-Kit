'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var coreTracing = require('@azure/core-tracing');
var types = require('@opentelemetry/types');
var qs = _interopDefault(require('qs'));
var coreHttp = require('@azure/core-http');
var logger$1 = require('@azure/logger');
var jws = _interopDefault(require('jws'));
var uuid = _interopDefault(require('uuid'));
var fs = require('fs');
var crypto = require('crypto');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
function isErrorResponse(errorResponse) {
    return (errorResponse &&
        typeof errorResponse.error === "string" &&
        typeof errorResponse.error_description === "string");
}
/**
 * The Error.name value of an AuthenticationError
 */
const AuthenticationErrorName = "AuthenticationError";
/**
 * Provides details about a failure to authenticate with Azure Active
 * Directory.  The `errorResponse` field contains more details about
 * the specific failure.
 */
class AuthenticationError extends Error {
    constructor(statusCode, errorBody) {
        let errorResponse = {
            error: "unknown",
            errorDescription: "An unknown error occurred and no additional details are available."
        };
        if (isErrorResponse(errorBody)) {
            errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
        }
        else if (typeof errorBody === "string") {
            try {
                // Most error responses will contain JSON-formatted error details
                // in the response body        
                const oauthErrorResponse = JSON.parse(errorBody);
                errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
            }
            catch (e) {
                if (statusCode === 400) {
                    errorResponse = {
                        error: "authority_not_found",
                        errorDescription: "The specified authority URL was not found."
                    };
                }
                else {
                    errorResponse = {
                        error: "unknown_error",
                        errorDescription: `An unknown error has occurred. Response body:\n\n${errorBody}`
                    };
                }
            }
        }
        else {
            errorResponse = {
                error: "unknown_error",
                errorDescription: "An unknown error occurred and no additional details are available."
            };
        }
        super(`An error was returned while authenticating to Azure Active Directory (status code ${statusCode}).\n\nMore details:\n\n${JSON.stringify(errorResponse, null, "  ")}`);
        this.statusCode = statusCode;
        this.errorResponse = errorResponse;
        // Ensure that this type reports the correct name
        this.name = AuthenticationErrorName;
    }
}
/**
 * The Error.name value of an AggregateAuthenticationError
 */
const AggregateAuthenticationErrorName = "AggregateAuthenticationError";
/**
 * Provides an `errors` array containing {@link AuthenticationError} instance
 * for authentication failures from credentials in a {@link ChainedTokenCredential}.
 */
class AggregateAuthenticationError extends Error {
    constructor(errors) {
        super(`Authentication failed to complete due to the following errors:\n\n${errors.join("\n\n")}`);
        this.errors = errors;
        // Ensure that this type reports the correct name
        this.name = AggregateAuthenticationErrorName;
    }
}
function convertOAuthErrorResponseToErrorResponse(errorBody) {
    return {
        error: errorBody.error,
        errorDescription: errorBody.error_description,
        correlationId: errorBody.correlation_id,
        errorCodes: errorBody.error_codes,
        timestamp: errorBody.timestamp,
        traceId: errorBody.trace_id
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @param name The name of the operation being performed.
 * @param options The options for the underlying http request.
 */
function createSpan(operationName, options = {}) {
    const tracer = coreTracing.getTracer();
    const tracingOptions = Object.assign({ spanOptions: {} }, options.tracingOptions);
    tracingOptions.spanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { kind: types.SpanKind.CLIENT });
    const span = tracer.startSpan(`Azure.Identity.${operationName}`, tracingOptions.spanOptions);
    span.setAttribute("component", "identity");
    let newOptions = options;
    if (span.isRecording()) {
        newOptions = Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, tracingOptions), { spanOptions: Object.assign(Object.assign({}, tracingOptions.spanOptions), { parent: span }) }) });
    }
    return {
        span,
        options: newOptions
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Enables multiple `TokenCredential` implementations to be tried in order
 * until one of the getToken methods returns an access token.
 */
class ChainedTokenCredential {
    /**
     * Creates an instance of ChainedTokenCredential using the given credentials.
     *
     * @param sources `TokenCredential` implementations to be tried in order.
     *
     * Example usage:
     * ```javascript
     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
     * ```
     */
    constructor(...sources) {
        this._sources = [];
        this._sources = sources;
    }
    /**
     * Returns the first access token returned by one of the chained
     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
     * when one or more credentials throws an {@link AuthenticationError} and
     * no credentials have returned an access token.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                `TokenCredential` implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let token = null;
            const errors = [];
            const { span, options: newOptions } = createSpan("ChainedTokenCredential-getToken", options);
            for (let i = 0; i < this._sources.length && token === null; i++) {
                try {
                    token = yield this._sources[i].getToken(scopes, newOptions);
                }
                catch (err) {
                    errors.push(err);
                }
            }
            if (!token && errors.length > 0) {
                const err = new AggregateAuthenticationError(errors);
                span.setStatus({
                    code: types.CanonicalCode.UNAUTHENTICATED,
                    message: err.message
                });
                throw err;
            }
            span.end();
            return token;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The AzureLogger used for all clients within the identity package
 */
const logger = logger$1.createClientLogger("identity");

// Copyright (c) Microsoft Corporation.
const DefaultAuthorityHost = "https://login.microsoftonline.com";
class IdentityClient extends coreHttp.ServiceClient {
    constructor(options) {
        options = options || IdentityClient.getDefaultOptions();
        super(undefined, coreHttp.createPipelineFromOptions(options));
        this.baseUri = this.authorityHost = options.authorityHost || DefaultAuthorityHost;
        if (!this.baseUri.startsWith("https:")) {
            throw new Error("The authorityHost address must use the 'https' protocol.");
        }
    }
    createWebResource(requestOptions) {
        const webResource = new coreHttp.WebResource();
        webResource.prepare(requestOptions);
        return webResource;
    }
    sendTokenRequest(webResource, expiresOnParser) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            logger.info(`IdentityClient: sending token request to [${webResource.url}]`);
            const response = yield this.sendRequest(webResource);
            expiresOnParser =
                expiresOnParser ||
                    ((responseBody) => {
                        return Date.now() + responseBody.expires_in * 1000;
                    });
            if (response.status === 200 || response.status === 201) {
                const token = {
                    accessToken: {
                        token: response.parsedBody.access_token,
                        expiresOnTimestamp: expiresOnParser(response.parsedBody)
                    },
                    refreshToken: response.parsedBody.refresh_token
                };
                logger.info(`IdentityClient: [${webResource.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
                return token;
            }
            else {
                const error = new AuthenticationError(response.status, response.parsedBody || response.bodyAsText);
                logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
                throw error;
            }
        });
    }
    refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (refreshToken === undefined) {
                return null;
            }
            logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
            const { span, options: newOptions } = createSpan("IdentityClient-refreshAccessToken", options);
            const refreshParams = {
                grant_type: "refresh_token",
                client_id: clientId,
                refresh_token: refreshToken,
                scope: scopes
            };
            if (clientSecret !== undefined) {
                refreshParams.client_secret = clientSecret;
            }
            try {
                const webResource = this.createWebResource({
                    url: `${this.authorityHost}/${tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify(refreshParams),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions,
                    abortSignal: options && options.abortSignal
                });
                const response = yield this.sendTokenRequest(webResource, expiresOnParser);
                logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
                return response;
            }
            catch (err) {
                if (err.name === AuthenticationErrorName &&
                    err.errorResponse.error === "interaction_required") {
                    // It's likely that the refresh token has expired, so
                    // return null so that the credential implementation will
                    // initiate the authentication flow again.
                    logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);
                    span.setStatus({
                        code: types.CanonicalCode.UNAUTHENTICATED,
                        message: err.message
                    });
                    return null;
                }
                else {
                    logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
                    span.setStatus({
                        code: types.CanonicalCode.UNKNOWN,
                        message: err.message
                    });
                    throw err;
                }
            }
            finally {
                span.end();
            }
        });
    }
    static getDefaultOptions() {
        return {
            authorityHost: DefaultAuthorityHost
        };
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Enables authentication to Azure Active Directory using a client secret
 * that was generated for an App Registration.  More information on how
 * to configure a client secret can be found here:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application
 *
 */
class ClientSecretCredential {
    /**
     * Creates an instance of the ClientSecretCredential with the details
     * needed to authenticate against Azure Active Directory with a client
     * secret.
     *
     * @param tenantId The Azure Active Directory tenant (directory) ID.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param clientSecret A client secret that was generated for the App Registration.
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, clientSecret, options) {
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("ClientSecretCredential-getToken", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        response_type: "token",
                        grant_type: "client_credentials",
                        client_id: this.clientId,
                        client_secret: this.clientSecret,
                        scope: typeof scopes === "string" ? scopes : scopes.join(" ")
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                const tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? types.CanonicalCode.UNAUTHENTICATED
                    : types.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
const SelfSignedJwtLifetimeMins = 10;
function timestampInSeconds(date) {
    return Math.floor(date.getTime() / 1000);
}
function addMinutes(date, minutes) {
    date.setMinutes(date.getMinutes() + minutes);
    return date;
}
/**
 * Enables authentication to Azure Active Directory using a PEM-encoded
 * certificate that is assigned to an App Registration.  More information
 * on how to configure certificate authentication can be found here:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-certificate-credentials#register-your-certificate-with-azure-ad
 *
 */
class ClientCertificateCredential {
    /**
     * Creates an instance of the ClientCertificateCredential with the details
     * needed to authenticate against Azure Active Directory with a certificate.
     *
     * @param tenantId The Azure Active Directory tenant (directory) ID.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param certificatePath The path to a PEM-encoded public/private key certificate on the filesystem.
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, certificatePath, options) {
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.certificateString = fs.readFileSync(certificatePath, "utf8");
        const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/;
        const matchCert = this.certificateString.match(certificatePattern);
        const publicKey = matchCert ? matchCert[3] : "";
        if (!publicKey) {
            throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
        }
        this.certificateThumbprint = crypto.createHash("sha1")
            .update(Buffer.from(publicKey, "base64"))
            .digest("hex")
            .toUpperCase();
        this.certificateX5t = Buffer.from(this.certificateThumbprint, "hex").toString("base64");
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("ClientCertificateCredential-getToken", options);
            try {
                const tokenId = uuid.v4();
                const audienceUrl = `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`;
                const header = {
                    typ: "JWT",
                    alg: "RS256",
                    x5t: this.certificateX5t
                };
                const payload = {
                    iss: this.clientId,
                    sub: this.clientId,
                    aud: audienceUrl,
                    jti: tokenId,
                    nbf: timestampInSeconds(new Date()),
                    exp: timestampInSeconds(addMinutes(new Date(), SelfSignedJwtLifetimeMins))
                };
                const clientAssertion = jws.sign({
                    header,
                    payload,
                    secret: this.certificateString
                });
                const webResource = this.identityClient.createWebResource({
                    url: audienceUrl,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        response_type: "token",
                        grant_type: "client_credentials",
                        client_id: this.clientId,
                        client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
                        client_assertion: clientAssertion,
                        scope: typeof scopes === "string" ? scopes : scopes.join(" ")
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                const tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? types.CanonicalCode.UNAUTHENTICATED
                    : types.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Enables authentication to Azure Active Directory with a user's
 * username and password. This credential requires a high degree of
 * trust so you should only use it when other, more secure credential
 * types can't be used.
 */
class UsernamePasswordCredential {
    /**
     * Creates an instance of the UsernamePasswordCredential with the details
     * needed to authenticate against Azure Active Directory with a username
     * and password.
     *
     * @param tenantIdOrName The Azure Active Directory tenant (directory) ID or name.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param username The user account's e-mail address (user name).
     * @param password The user account's account password
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantIdOrName, clientId, username, password, options) {
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantIdOrName;
        this.clientId = clientId;
        this.username = username;
        this.password = password;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("UsernamePasswordCredential-getToken", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        response_type: "token",
                        grant_type: "password",
                        client_id: this.clientId,
                        username: this.username,
                        password: this.password,
                        scope: typeof scopes === "string" ? scopes : scopes.join(" ")
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                const tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? types.CanonicalCode.UNAUTHENTICATED
                    : types.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Contains the list of all supported environment variable names so that an
 * appropriate error message can be generated when no credentials can be
 * configured.
 *
 * @internal
 */
const AllSupportedEnvironmentVariables = [
    "AZURE_TENANT_ID",
    "AZURE_CLIENT_ID",
    "AZURE_CLIENT_SECRET",
    "AZURE_CLIENT_CERTIFICATE_PATH",
    "AZURE_USERNAME",
    "AZURE_PASSWORD"
];
/**
 * Enables authentication to Azure Active Directory using client secret
 * details configured in the following environment variables:
 *
 * - AZURE_TENANT_ID: The Azure Active Directory tenant (directory) ID.
 * - AZURE_CLIENT_ID: The client (application) ID of an App Registration in the tenant.
 * - AZURE_CLIENT_SECRET: A client secret that was generated for the App Registration.
 *
 * This credential ultimately uses a {@link ClientSecretCredential} to
 * perform the authentication using these details.  Please consult the
 * documentation of that class for more details.
 */
class EnvironmentCredential {
    /**
     * Creates an instance of the EnvironmentCredential class and reads
     * client secret details from environment variables.  If the expected
     * environment variables are not found at this time, the getToken method
     * will return null when invoked.
     *
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(options) {
        this._environmentVarsMissing = [];
        this._credential = undefined;
        // Keep track of any missing environment variables for error details
        this._environmentVarsMissing = AllSupportedEnvironmentVariables.filter((v) => process.env[v] === undefined);
        const tenantId = process.env.AZURE_TENANT_ID, clientId = process.env.AZURE_CLIENT_ID, clientSecret = process.env.AZURE_CLIENT_SECRET;
        if (tenantId && clientId && clientSecret) {
            logger.info(`EnvironmentCredential: loaded with tenant ID: ${tenantId}, clientId: ${clientId}`);
            this._credential = new ClientSecretCredential(tenantId, clientId, clientSecret, options);
            return;
        }
        const certificatePath = process.env.AZURE_CLIENT_CERTIFICATE_PATH;
        if (tenantId && clientId && certificatePath) {
            logger.info(`EnvironmentCredential: loaded with tenant ID: ${tenantId}, clientId: ${clientId}, certificatePath: ${certificatePath}`);
            this._credential = new ClientCertificateCredential(tenantId, clientId, certificatePath, options);
            return;
        }
        const username = process.env.AZURE_USERNAME;
        const password = process.env.AZURE_PASSWORD;
        if (tenantId && clientId && username && password) {
            logger.info(`EnvironmentCredential: loaded with tenant ID: ${tenantId}, clientId: ${clientId}, username: ${username}`);
            this._credential = new UsernamePasswordCredential(tenantId, clientId, username, password, options);
        }
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("EnvironmentCredential-getToken", options);
            if (this._credential) {
                try {
                    return yield this._credential.getToken(scopes, newOptions);
                }
                catch (err) {
                    const code = err.name === AuthenticationErrorName
                        ? types.CanonicalCode.UNAUTHENTICATED
                        : types.CanonicalCode.UNKNOWN;
                    span.setStatus({
                        code,
                        message: err.message
                    });
                    throw err;
                }
                finally {
                    span.end();
                }
            }
            // If by this point we don't have a credential, throw an exception so that
            // the user knows the credential was not configured appropriately
            span.setStatus({ code: types.CanonicalCode.UNAUTHENTICATED });
            span.end();
            throw new AuthenticationError(400, {
                error: "missing_environment_variables",
                error_description: `EnvironmentCredential cannot return a token because one or more of the following environment variables is missing:

${this._environmentVarsMissing.join("\n")}

To authenticate with a service principal AZURE_TENANT_ID, AZURE_CLIENT_ID, and either AZURE_CLIENT_SECRET or AZURE_CLIENT_CERTIFICATE_PATH must be set.  To authenticate with a user account AZURE_TENANT_ID, AZURE_USERNAME, and AZURE_PASSWORD must be set.
`
            });
        });
    }
}

// Copyright (c) Microsoft Corporation.
const DefaultScopeSuffix = "/.default";
const ImdsEndpoint = "http://169.254.169.254/metadata/identity/oauth2/token";
const ImdsApiVersion = "2018-02-01";
const AppServiceMsiApiVersion = "2017-09-01";
/**
 * Attempts authentication using a managed identity that has been assigned
 * to the deployment environment.  This authentication type works in Azure VMs,
 * App Service and Azure Functions applications, and inside of Azure Cloud Shell.
 *
 * More information about configuring managed identities can be found here:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
 */
class ManagedIdentityCredential {
    /**
     * @internal
     * @ignore
     */
    constructor(clientIdOrOptions, options) {
        this.isEndpointUnavailable = null;
        if (typeof clientIdOrOptions === "string") {
            // clientId, options constructor
            this.clientId = clientIdOrOptions;
            this.identityClient = new IdentityClient(options);
        }
        else {
            // options only constructor
            this.identityClient = new IdentityClient(clientIdOrOptions);
        }
    }
    mapScopesToResource(scopes) {
        let scope = "";
        if (Array.isArray(scopes)) {
            if (scopes.length !== 1) {
                throw "To convert to a resource string the specified array must be exactly length 1";
            }
            scope = scopes[0];
        }
        else if (typeof scopes === "string") {
            scope = scopes;
        }
        if (!scope.endsWith(DefaultScopeSuffix)) {
            return scope;
        }
        return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));
    }
    createImdsAuthRequest(resource, clientId) {
        const queryParameters = {
            resource,
            "api-version": ImdsApiVersion
        };
        if (clientId) {
            queryParameters.client_id = clientId;
        }
        return {
            url: ImdsEndpoint,
            method: "GET",
            queryParameters,
            headers: {
                Accept: "application/json",
                Metadata: true
            }
        };
    }
    createAppServiceMsiAuthRequest(resource, clientId) {
        const queryParameters = {
            resource,
            "api-version": AppServiceMsiApiVersion
        };
        if (clientId) {
            queryParameters.clientid = clientId;
        }
        return {
            url: process.env.MSI_ENDPOINT,
            method: "GET",
            queryParameters,
            headers: {
                Accept: "application/json",
                secret: process.env.MSI_SECRET
            }
        };
    }
    createCloudShellMsiAuthRequest(resource, clientId) {
        const body = {
            resource
        };
        if (clientId) {
            body.client_id = clientId;
        }
        return {
            url: process.env.MSI_ENDPOINT,
            method: "POST",
            body: qs.stringify(body),
            headers: {
                Accept: "application/json",
                Metadata: true,
                "Content-Type": "application/x-www-form-urlencoded"
            }
        };
    }
    pingImdsEndpoint(resource, clientId, getTokenOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options } = createSpan("ManagedIdentityCredential-pingImdsEndpoint", getTokenOptions);
            const request = this.createImdsAuthRequest(resource, clientId);
            // This will always be populated, but let's make TypeScript happy
            if (request.headers) {
                // Remove the Metadata header to invoke a request error from
                // IMDS endpoint
                delete request.headers.Metadata;
            }
            request.spanOptions = options.tracingOptions && options.tracingOptions.spanOptions;
            try {
                // Create a request with a timeout since we expect that
                // not having a "Metadata" header should cause an error to be
                // returned quickly from the endpoint, proving its availability.
                const webResource = this.identityClient.createWebResource(request);
                webResource.timeout = (options.requestOptions && options.requestOptions.timeout) || 500;
                try {
                    logger.info(`ManagedIdentityCredential: pinging IMDS endpoint`);
                    yield this.identityClient.sendRequest(webResource);
                }
                catch (err) {
                    if ((err instanceof coreHttp.RestError && err.code === coreHttp.RestError.REQUEST_SEND_ERROR) ||
                        err.name === "AbortError") {
                        // Either request failed or IMDS endpoint isn't available
                        logger.info(`ManagedIdentityCredential: IMDS endpoint unavailable`);
                        span.setStatus({
                            code: types.CanonicalCode.UNAVAILABLE,
                            message: err.message
                        });
                        return false;
                    }
                }
                // If we received any response, the endpoint is available
                logger.info(`ManagedIdentityCredential: IMDS endpoint is available`);
                return true;
            }
            catch (err) {
                logger.warning(`ManagedIdentityCredential: error when accessing IMDS endpoint: ${err}`);
                span.setStatus({
                    code: types.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    authenticateManagedIdentity(scopes, checkIfImdsEndpointAvailable, clientId, getTokenOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let authRequestOptions;
            const resource = this.mapScopesToResource(scopes);
            let expiresInParser;
            const { span, options } = createSpan("ManagedIdentityCredential-authenticateManagedIdentity", getTokenOptions);
            try {
                // Detect which type of environment we are running in
                if (process.env.MSI_ENDPOINT) {
                    if (process.env.MSI_SECRET) {
                        // Running in App Service
                        authRequestOptions = this.createAppServiceMsiAuthRequest(resource, clientId);
                        expiresInParser = (requestBody) => {
                            // Parse a date format like "06/20/2019 02:57:58 +00:00" and
                            // convert it into a JavaScript-formatted date
                            return Date.parse(requestBody.expires_on);
                        };
                    }
                    else {
                        // Running in Cloud Shell
                        authRequestOptions = this.createCloudShellMsiAuthRequest(resource, clientId);
                    }
                }
                else {
                    // Ping the IMDS endpoint to see if it's available
                    if (!checkIfImdsEndpointAvailable ||
                        (yield this.pingImdsEndpoint(resource, clientId, options))) {
                        // Running in an Azure VM
                        authRequestOptions = this.createImdsAuthRequest(resource, clientId);
                    }
                    else {
                        // Returning null tells the ManagedIdentityCredential that
                        // no MSI authentication endpoints are available
                        return null;
                    }
                }
                const webResource = this.identityClient.createWebResource(Object.assign({ disableJsonStringifyOnBody: true, deserializationMapper: undefined, abortSignal: options.abortSignal, spanOptions: options.tracingOptions && options.tracingOptions.spanOptions }, authRequestOptions));
                const tokenResponse = yield this.identityClient.sendTokenRequest(webResource, expiresInParser);
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? types.CanonicalCode.UNAUTHENTICATED
                    : types.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let result = null;
            const { span, options: newOptions } = createSpan("ManagedIdentityCredential-getToken", options);
            try {
                // isEndpointAvailable can be true, false, or null,
                // the latter indicating that we don't yet know whether
                // the endpoint is available and need to check for it.
                if (this.isEndpointUnavailable !== true) {
                    result = yield this.authenticateManagedIdentity(scopes, this.isEndpointUnavailable === null, this.clientId, newOptions);
                    // If authenticateManagedIdentity returns null, it means no MSI
                    // endpoints are available.  In this case, don't try them in future
                    // requests.
                    this.isEndpointUnavailable = result === null;
                }
                return result;
            }
            catch (err) {
                span.setStatus({
                    code: types.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provides a default {@link ChainedTokenCredential} configuration for
 * applications that will be deployed to Azure.  The following credential
 * types will be tried, in order:
 *
 * - {@link EnvironmentCredential}
 * - {@link ManagedIdentityCredential}
 *
 * Consult the documentation of these credential types for more information
 * on how they attempt authentication.
 */
class DefaultAzureCredential extends ChainedTokenCredential {
    /**
     * Creates an instance of the DefaultAzureCredential class.
     *
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tokenCredentialOptions) {
        super(new EnvironmentCredential(tokenCredentialOptions), new ManagedIdentityCredential(tokenCredentialOptions));
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const BrowserNotSupportedError = new Error("InteractiveBrowserCredential is not supported in Node.js.");
/**
 * Enables authentication to Azure Active Directory inside of the web browser
 * using the interactive login flow, either via browser redirects or a popup
 * window.  This credential is not currently supported in Node.js.
 */
class InteractiveBrowserCredential {
    constructor(options) {
        throw BrowserNotSupportedError;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        throw BrowserNotSupportedError;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
let testFunction;
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @internal
 * @param {number} t The number of milliseconds to be delayed.
 * @returns {Promise<void>} Resolved promise
 */
function delay(t) {
    if (testFunction) {
        return testFunction(t);
    }
    return new Promise((resolve) => setTimeout(() => resolve(), t));
}

// Copyright (c) Microsoft Corporation.
/**
 * Enables authentication to Azure Active Directory using a device code
 * that the user can enter into https://microsoft.com/devicelogin.
 */
class DeviceCodeCredential {
    /**
     * Creates an instance of DeviceCodeCredential with the details needed
     * to initiate the device code authorization flow with Azure Active Directory.
     *
     * @param tenantId The Azure Active Directory tenant (directory) ID or name.
     *                 'organizations' may be used when dealing with multi-tenant scenarios.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param userPromptCallback A callback function that will be invoked to show
                                 {@link DeviceCodeInfo} to the user.
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, userPromptCallback, options) {
        this.lastTokenResponse = null;
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.userPromptCallback = userPromptCallback;
    }
    sendDeviceCodeRequest(scope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-sendDeviceCodeRequest", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/devicecode`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        client_id: this.clientId,
                        scope
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                logger.info("DeviceCodeCredential: sending devicecode request");
                const response = yield this.identityClient.sendRequest(webResource);
                if (!(response.status === 200 || response.status === 201)) {
                    throw new AuthenticationError(response.status, response.bodyAsText);
                }
                return response.parsedBody;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? types.CanonicalCode.UNAUTHENTICATED
                    : types.CanonicalCode.UNKNOWN;
                if (err.name === AuthenticationErrorName) {
                    logger.warning(`DeviceCodeCredential: failed to authenticate ${err.errorResponse.errorDescription}`);
                }
                else {
                    logger.warning(`DeviceCodeCredential: failed to authenticate ${err}`);
                }
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    pollForToken(deviceCodeResponse, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let tokenResponse = null;
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-pollForToken", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        grant_type: "urn:ietf:params:oauth:grant-type:device_code",
                        client_id: this.clientId,
                        device_code: deviceCodeResponse.device_code
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                while (tokenResponse === null) {
                    try {
                        yield delay(deviceCodeResponse.interval * 1000);
                        // Check the abort signal before sending the request
                        if (options && options.abortSignal && options.abortSignal.aborted) {
                            return null;
                        }
                        tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                    }
                    catch (err) {
                        if (err.name === AuthenticationErrorName) {
                            switch (err.errorResponse.error) {
                                case "authorization_pending":
                                    break;
                                case "authorization_declined":
                                    return null;
                                case "expired_token":
                                    throw err;
                                case "bad_verification_code":
                                    throw err;
                                default:
                                    // Any other error should be rethrown
                                    throw err;
                            }
                        }
                        else {
                            throw err;
                        }
                    }
                }
                return tokenResponse;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? types.CanonicalCode.UNAUTHENTICATED
                    : types.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-getToken", options);
            try {
                let tokenResponse = null;
                let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
                if (scopeString.indexOf("offline_access") < 0) {
                    scopeString += " offline_access";
                }
                // Try to use the refresh token first
                if (this.lastTokenResponse && this.lastTokenResponse.refreshToken) {
                    tokenResponse = yield this.identityClient.refreshAccessToken(this.tenantId, this.clientId, scopeString, this.lastTokenResponse.refreshToken, undefined, // clientSecret not needed for device code auth
                    undefined, newOptions);
                }
                if (tokenResponse === null) {
                    const deviceCodeResponse = yield this.sendDeviceCodeRequest(scopeString, newOptions);
                    this.userPromptCallback({
                        userCode: deviceCodeResponse.user_code,
                        verificationUri: deviceCodeResponse.verification_uri,
                        message: deviceCodeResponse.message
                    });
                    tokenResponse = yield this.pollForToken(deviceCodeResponse, newOptions);
                }
                this.lastTokenResponse = tokenResponse;
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? types.CanonicalCode.UNAUTHENTICATED
                    : types.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Enables authentication to Azure Active Directory using an authorization code
 * that was obtained through the authorization code flow, described in more detail
 * in the Azure Active Directory documentation:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow
 */
class AuthorizationCodeCredential {
    /**
     * @ignore
     * @internal
     */
    constructor(tenantId, clientId, clientSecretOrAuthorizationCode, authorizationCodeOrRedirectUri, redirectUriOrOptions, options) {
        this.lastTokenResponse = null;
        this.clientId = clientId;
        this.tenantId = tenantId;
        if (typeof redirectUriOrOptions === "string") {
            // the clientId+clientSecret constructor
            this.clientSecret = clientSecretOrAuthorizationCode;
            this.authorizationCode = authorizationCodeOrRedirectUri;
            this.redirectUri = redirectUriOrOptions;
            // options okay
        }
        else {
            // clientId only
            this.clientSecret = undefined;
            this.authorizationCode = clientSecretOrAuthorizationCode;
            this.redirectUri = authorizationCodeOrRedirectUri;
            options = redirectUriOrOptions;
        }
        this.identityClient = new IdentityClient(options);
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("AuthorizationCodeCredential-getToken", options);
            try {
                let tokenResponse = null;
                let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
                if (scopeString.indexOf("offline_access") < 0) {
                    scopeString += " offline_access";
                }
                // Try to use the refresh token first
                if (this.lastTokenResponse && this.lastTokenResponse.refreshToken) {
                    tokenResponse = yield this.identityClient.refreshAccessToken(this.tenantId, this.clientId, scopeString, this.lastTokenResponse.refreshToken, this.clientSecret, undefined, newOptions);
                }
                if (tokenResponse === null) {
                    const webResource = this.identityClient.createWebResource({
                        url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                        method: "POST",
                        disableJsonStringifyOnBody: true,
                        deserializationMapper: undefined,
                        body: qs.stringify({
                            client_id: this.clientId,
                            grant_type: "authorization_code",
                            scope: scopeString,
                            code: this.authorizationCode,
                            redirect_uri: this.redirectUri,
                            client_secret: this.clientSecret
                        }),
                        headers: {
                            Accept: "application/json",
                            "Content-Type": "application/x-www-form-urlencoded"
                        },
                        abortSignal: options && options.abortSignal,
                        spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                    });
                    tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                }
                this.lastTokenResponse = tokenResponse;
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? types.CanonicalCode.UNAUTHENTICATED
                    : types.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Returns a new instance of the {@link DefaultAzureCredential}.
 */
function getDefaultAzureCredential() {
    return new DefaultAzureCredential();
}

exports.AggregateAuthenticationError = AggregateAuthenticationError;
exports.AggregateAuthenticationErrorName = AggregateAuthenticationErrorName;
exports.AuthenticationError = AuthenticationError;
exports.AuthenticationErrorName = AuthenticationErrorName;
exports.AuthorizationCodeCredential = AuthorizationCodeCredential;
exports.ChainedTokenCredential = ChainedTokenCredential;
exports.ClientCertificateCredential = ClientCertificateCredential;
exports.ClientSecretCredential = ClientSecretCredential;
exports.DefaultAzureCredential = DefaultAzureCredential;
exports.DeviceCodeCredential = DeviceCodeCredential;
exports.EnvironmentCredential = EnvironmentCredential;
exports.InteractiveBrowserCredential = InteractiveBrowserCredential;
exports.ManagedIdentityCredential = ManagedIdentityCredential;
exports.UsernamePasswordCredential = UsernamePasswordCredential;
exports.getDefaultAzureCredential = getDefaultAzureCredential;
exports.logger = logger;
//# sourceMappingURL=index.js.map
